{
  "kind": "esbuild::Bundle",
  "id": "bundle",
  "fqn": "my-userdo-app/root/my-userdo-worker/bundle",
  "seq": 0,
  "data": {},
  "status": "updated",
  "output": {
    "Symbol(alchemy::ResourceKind)": "esbuild::Bundle",
    "Symbol(alchemy::ResourceID)": "bundle",
    "Symbol(alchemy::ResourceFQN)": "my-userdo-app/root/my-userdo-worker/bundle",
    "Symbol(alchemy::ResourceScope)": {
      "@scope": null
    },
    "Symbol(alchemy::ResourceSeq)": 0,
    "entryPoint": "./src/worker.ts",
    "format": "esm",
    "target": "esnext",
    "platform": "node",
    "minify": false,
    "conditions": [
      "workerd",
      "worker",
      "browser"
    ],
    "absWorkingDir": "/srv/userdo/examples/alchemy",
    "keepNames": true,
    "loader": {
      ".sql": "text",
      ".json": "json"
    },
    "plugins": [
      {
        "name": "wasm"
      }
    ],
    "external": [
      "node:async_hooks",
      "node:assert",
      "node:buffer",
      "node:console",
      "node:crypto",
      "node:debug",
      "node:diagnostics_channel",
      "node:dns",
      "node:events",
      "node:inspector",
      "node:net",
      "node:path",
      "node:perf_hooks",
      "node:process",
      "node:querystring",
      "node:stream",
      "node:string_decoder",
      "node:timers",
      "node:tls",
      "node:url",
      "node:util",
      "node:zlib",
      "async_hooks",
      "assert",
      "buffer",
      "console",
      "crypto",
      "debug",
      "diagnostics_channel",
      "dns",
      "events",
      "inspector",
      "net",
      "path",
      "perf_hooks",
      "process",
      "querystring",
      "stream",
      "string_decoder",
      "timers",
      "tls",
      "url",
      "util",
      "zlib",
      "cloudflare:workers",
      "cloudflare:workflows",
      "cloudflare:*"
    ],
    "path": ".out/worker.js",
    "hash": "7SOsYwy3v3A",
    "content": "var __defProp = Object.defineProperty;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// node_modules/zod/dist/esm/v3/helpers/util.js\nvar util, objectUtil, ZodParsedType, getParsedType;\nvar init_util = __esm({\n  \"node_modules/zod/dist/esm/v3/helpers/util.js\"() {\n    (function(util2) {\n      util2.assertEqual = (_) => {\n      };\n      function assertIs(_arg) {\n      }\n      __name(assertIs, \"assertIs\");\n      util2.assertIs = assertIs;\n      function assertNever(_x) {\n        throw new Error();\n      }\n      __name(assertNever, \"assertNever\");\n      util2.assertNever = assertNever;\n      util2.arrayToEnum = (items) => {\n        const obj = {};\n        for (const item of items) {\n          obj[item] = item;\n        }\n        return obj;\n      };\n      util2.getValidEnumValues = (obj) => {\n        const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys) {\n          filtered[k] = obj[k];\n        }\n        return util2.objectValues(filtered);\n      };\n      util2.objectValues = (obj) => {\n        return util2.objectKeys(obj).map(function(e) {\n          return obj[e];\n        });\n      };\n      util2.objectKeys = typeof Object.keys === \"function\" ? (obj) => Object.keys(obj) : (object) => {\n        const keys = [];\n        for (const key in object) {\n          if (Object.prototype.hasOwnProperty.call(object, key)) {\n            keys.push(key);\n          }\n        }\n        return keys;\n      };\n      util2.find = (arr, checker) => {\n        for (const item of arr) {\n          if (checker(item))\n            return item;\n        }\n        return void 0;\n      };\n      util2.isInteger = typeof Number.isInteger === \"function\" ? (val) => Number.isInteger(val) : (val) => typeof val === \"number\" && Number.isFinite(val) && Math.floor(val) === val;\n      function joinValues(array, separator = \" | \") {\n        return array.map((val) => typeof val === \"string\" ? `'${val}'` : val).join(separator);\n      }\n      __name(joinValues, \"joinValues\");\n      util2.joinValues = joinValues;\n      util2.jsonStringifyReplacer = (_, value) => {\n        if (typeof value === \"bigint\") {\n          return value.toString();\n        }\n        return value;\n      };\n    })(util || (util = {}));\n    (function(objectUtil2) {\n      objectUtil2.mergeShapes = (first, second) => {\n        return {\n          ...first,\n          ...second\n          // second overwrites first\n        };\n      };\n    })(objectUtil || (objectUtil = {}));\n    ZodParsedType = util.arrayToEnum([\n      \"string\",\n      \"nan\",\n      \"number\",\n      \"integer\",\n      \"float\",\n      \"boolean\",\n      \"date\",\n      \"bigint\",\n      \"symbol\",\n      \"function\",\n      \"undefined\",\n      \"null\",\n      \"array\",\n      \"object\",\n      \"unknown\",\n      \"promise\",\n      \"void\",\n      \"never\",\n      \"map\",\n      \"set\"\n    ]);\n    getParsedType = /* @__PURE__ */ __name((data) => {\n      const t = typeof data;\n      switch (t) {\n        case \"undefined\":\n          return ZodParsedType.undefined;\n        case \"string\":\n          return ZodParsedType.string;\n        case \"number\":\n          return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n        case \"boolean\":\n          return ZodParsedType.boolean;\n        case \"function\":\n          return ZodParsedType.function;\n        case \"bigint\":\n          return ZodParsedType.bigint;\n        case \"symbol\":\n          return ZodParsedType.symbol;\n        case \"object\":\n          if (Array.isArray(data)) {\n            return ZodParsedType.array;\n          }\n          if (data === null) {\n            return ZodParsedType.null;\n          }\n          if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n            return ZodParsedType.promise;\n          }\n          if (typeof Map !== \"undefined\" && data instanceof Map) {\n            return ZodParsedType.map;\n          }\n          if (typeof Set !== \"undefined\" && data instanceof Set) {\n            return ZodParsedType.set;\n          }\n          if (typeof Date !== \"undefined\" && data instanceof Date) {\n            return ZodParsedType.date;\n          }\n          return ZodParsedType.object;\n        default:\n          return ZodParsedType.unknown;\n      }\n    }, \"getParsedType\");\n  }\n});\n\n// node_modules/zod/dist/esm/v3/ZodError.js\nvar ZodIssueCode, quotelessJson, ZodError;\nvar init_ZodError = __esm({\n  \"node_modules/zod/dist/esm/v3/ZodError.js\"() {\n    init_util();\n    ZodIssueCode = util.arrayToEnum([\n      \"invalid_type\",\n      \"invalid_literal\",\n      \"custom\",\n      \"invalid_union\",\n      \"invalid_union_discriminator\",\n      \"invalid_enum_value\",\n      \"unrecognized_keys\",\n      \"invalid_arguments\",\n      \"invalid_return_type\",\n      \"invalid_date\",\n      \"invalid_string\",\n      \"too_small\",\n      \"too_big\",\n      \"invalid_intersection_types\",\n      \"not_multiple_of\",\n      \"not_finite\"\n    ]);\n    quotelessJson = /* @__PURE__ */ __name((obj) => {\n      const json = JSON.stringify(obj, null, 2);\n      return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n    }, \"quotelessJson\");\n    ZodError = class _ZodError extends Error {\n      static {\n        __name(this, \"ZodError\");\n      }\n      get errors() {\n        return this.issues;\n      }\n      constructor(issues) {\n        super();\n        this.issues = [];\n        this.addIssue = (sub) => {\n          this.issues = [...this.issues, sub];\n        };\n        this.addIssues = (subs = []) => {\n          this.issues = [...this.issues, ...subs];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n          Object.setPrototypeOf(this, actualProto);\n        } else {\n          this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n      }\n      format(_mapper) {\n        const mapper = _mapper || function(issue) {\n          return issue.message;\n        };\n        const fieldErrors = { _errors: [] };\n        const processError = /* @__PURE__ */ __name((error) => {\n          for (const issue of error.issues) {\n            if (issue.code === \"invalid_union\") {\n              issue.unionErrors.map(processError);\n            } else if (issue.code === \"invalid_return_type\") {\n              processError(issue.returnTypeError);\n            } else if (issue.code === \"invalid_arguments\") {\n              processError(issue.argumentsError);\n            } else if (issue.path.length === 0) {\n              fieldErrors._errors.push(mapper(issue));\n            } else {\n              let curr = fieldErrors;\n              let i = 0;\n              while (i < issue.path.length) {\n                const el = issue.path[i];\n                const terminal = i === issue.path.length - 1;\n                if (!terminal) {\n                  curr[el] = curr[el] || { _errors: [] };\n                } else {\n                  curr[el] = curr[el] || { _errors: [] };\n                  curr[el]._errors.push(mapper(issue));\n                }\n                curr = curr[el];\n                i++;\n              }\n            }\n          }\n        }, \"processError\");\n        processError(this);\n        return fieldErrors;\n      }\n      static assert(value) {\n        if (!(value instanceof _ZodError)) {\n          throw new Error(`Not a ZodError: ${value}`);\n        }\n      }\n      toString() {\n        return this.message;\n      }\n      get message() {\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n      }\n      get isEmpty() {\n        return this.issues.length === 0;\n      }\n      flatten(mapper = (issue) => issue.message) {\n        const fieldErrors = {};\n        const formErrors = [];\n        for (const sub of this.issues) {\n          if (sub.path.length > 0) {\n            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n            fieldErrors[sub.path[0]].push(mapper(sub));\n          } else {\n            formErrors.push(mapper(sub));\n          }\n        }\n        return { formErrors, fieldErrors };\n      }\n      get formErrors() {\n        return this.flatten();\n      }\n    };\n    ZodError.create = (issues) => {\n      const error = new ZodError(issues);\n      return error;\n    };\n  }\n});\n\n// node_modules/zod/dist/esm/v3/locales/en.js\nvar errorMap, en_default;\nvar init_en = __esm({\n  \"node_modules/zod/dist/esm/v3/locales/en.js\"() {\n    init_ZodError();\n    init_util();\n    errorMap = /* @__PURE__ */ __name((issue, _ctx) => {\n      let message;\n      switch (issue.code) {\n        case ZodIssueCode.invalid_type:\n          if (issue.received === ZodParsedType.undefined) {\n            message = \"Required\";\n          } else {\n            message = `Expected ${issue.expected}, received ${issue.received}`;\n          }\n          break;\n        case ZodIssueCode.invalid_literal:\n          message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n          break;\n        case ZodIssueCode.unrecognized_keys:\n          message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n          break;\n        case ZodIssueCode.invalid_union:\n          message = `Invalid input`;\n          break;\n        case ZodIssueCode.invalid_union_discriminator:\n          message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n          break;\n        case ZodIssueCode.invalid_enum_value:\n          message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n          break;\n        case ZodIssueCode.invalid_arguments:\n          message = `Invalid function arguments`;\n          break;\n        case ZodIssueCode.invalid_return_type:\n          message = `Invalid function return type`;\n          break;\n        case ZodIssueCode.invalid_date:\n          message = `Invalid date`;\n          break;\n        case ZodIssueCode.invalid_string:\n          if (typeof issue.validation === \"object\") {\n            if (\"includes\" in issue.validation) {\n              message = `Invalid input: must include \"${issue.validation.includes}\"`;\n              if (typeof issue.validation.position === \"number\") {\n                message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n              }\n            } else if (\"startsWith\" in issue.validation) {\n              message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n            } else if (\"endsWith\" in issue.validation) {\n              message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n            } else {\n              util.assertNever(issue.validation);\n            }\n          } else if (issue.validation !== \"regex\") {\n            message = `Invalid ${issue.validation}`;\n          } else {\n            message = \"Invalid\";\n          }\n          break;\n        case ZodIssueCode.too_small:\n          if (issue.type === \"array\")\n            message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n          else if (issue.type === \"string\")\n            message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n          else if (issue.type === \"number\")\n            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n          else if (issue.type === \"date\")\n            message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;\n          else\n            message = \"Invalid input\";\n          break;\n        case ZodIssueCode.too_big:\n          if (issue.type === \"array\")\n            message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n          else if (issue.type === \"string\")\n            message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n          else if (issue.type === \"number\")\n            message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n          else if (issue.type === \"bigint\")\n            message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n          else if (issue.type === \"date\")\n            message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;\n          else\n            message = \"Invalid input\";\n          break;\n        case ZodIssueCode.custom:\n          message = `Invalid input`;\n          break;\n        case ZodIssueCode.invalid_intersection_types:\n          message = `Intersection results could not be merged`;\n          break;\n        case ZodIssueCode.not_multiple_of:\n          message = `Number must be a multiple of ${issue.multipleOf}`;\n          break;\n        case ZodIssueCode.not_finite:\n          message = \"Number must be finite\";\n          break;\n        default:\n          message = _ctx.defaultError;\n          util.assertNever(issue);\n      }\n      return { message };\n    }, \"errorMap\");\n    en_default = errorMap;\n  }\n});\n\n// node_modules/zod/dist/esm/v3/errors.js\nfunction setErrorMap(map) {\n  overrideErrorMap = map;\n}\nfunction getErrorMap() {\n  return overrideErrorMap;\n}\nvar overrideErrorMap;\nvar init_errors = __esm({\n  \"node_modules/zod/dist/esm/v3/errors.js\"() {\n    init_en();\n    overrideErrorMap = en_default;\n    __name(setErrorMap, \"setErrorMap\");\n    __name(getErrorMap, \"getErrorMap\");\n  }\n});\n\n// node_modules/zod/dist/esm/v3/helpers/parseUtil.js\nfunction addIssueToContext(ctx, issueData) {\n  const overrideMap = getErrorMap();\n  const issue = makeIssue({\n    issueData,\n    data: ctx.data,\n    path: ctx.path,\n    errorMaps: [\n      ctx.common.contextualErrorMap,\n      // contextual error map is first priority\n      ctx.schemaErrorMap,\n      // then schema-bound map if available\n      overrideMap,\n      // then global override map\n      overrideMap === en_default ? void 0 : en_default\n      // then global default map\n    ].filter((x) => !!x)\n  });\n  ctx.common.issues.push(issue);\n}\nvar makeIssue, EMPTY_PATH, ParseStatus, INVALID, DIRTY, OK, isAborted, isDirty, isValid, isAsync;\nvar init_parseUtil = __esm({\n  \"node_modules/zod/dist/esm/v3/helpers/parseUtil.js\"() {\n    init_errors();\n    init_en();\n    makeIssue = /* @__PURE__ */ __name((params) => {\n      const { data, path, errorMaps, issueData } = params;\n      const fullPath = [...path, ...issueData.path || []];\n      const fullIssue = {\n        ...issueData,\n        path: fullPath\n      };\n      if (issueData.message !== void 0) {\n        return {\n          ...issueData,\n          path: fullPath,\n          message: issueData.message\n        };\n      }\n      let errorMessage = \"\";\n      const maps = errorMaps.filter((m) => !!m).slice().reverse();\n      for (const map of maps) {\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n      }\n      return {\n        ...issueData,\n        path: fullPath,\n        message: errorMessage\n      };\n    }, \"makeIssue\");\n    EMPTY_PATH = [];\n    __name(addIssueToContext, \"addIssueToContext\");\n    ParseStatus = class _ParseStatus {\n      static {\n        __name(this, \"ParseStatus\");\n      }\n      constructor() {\n        this.value = \"valid\";\n      }\n      dirty() {\n        if (this.value === \"valid\")\n          this.value = \"dirty\";\n      }\n      abort() {\n        if (this.value !== \"aborted\")\n          this.value = \"aborted\";\n      }\n      static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results) {\n          if (s.status === \"aborted\")\n            return INVALID;\n          if (s.status === \"dirty\")\n            status.dirty();\n          arrayValue.push(s.value);\n        }\n        return { status: status.value, value: arrayValue };\n      }\n      static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs) {\n          const key = await pair.key;\n          const value = await pair.value;\n          syncPairs.push({\n            key,\n            value\n          });\n        }\n        return _ParseStatus.mergeObjectSync(status, syncPairs);\n      }\n      static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs) {\n          const { key, value } = pair;\n          if (key.status === \"aborted\")\n            return INVALID;\n          if (value.status === \"aborted\")\n            return INVALID;\n          if (key.status === \"dirty\")\n            status.dirty();\n          if (value.status === \"dirty\")\n            status.dirty();\n          if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n            finalObject[key.value] = value.value;\n          }\n        }\n        return { status: status.value, value: finalObject };\n      }\n    };\n    INVALID = Object.freeze({\n      status: \"aborted\"\n    });\n    DIRTY = /* @__PURE__ */ __name((value) => ({ status: \"dirty\", value }), \"DIRTY\");\n    OK = /* @__PURE__ */ __name((value) => ({ status: \"valid\", value }), \"OK\");\n    isAborted = /* @__PURE__ */ __name((x) => x.status === \"aborted\", \"isAborted\");\n    isDirty = /* @__PURE__ */ __name((x) => x.status === \"dirty\", \"isDirty\");\n    isValid = /* @__PURE__ */ __name((x) => x.status === \"valid\", \"isValid\");\n    isAsync = /* @__PURE__ */ __name((x) => typeof Promise !== \"undefined\" && x instanceof Promise, \"isAsync\");\n  }\n});\n\n// node_modules/zod/dist/esm/v3/helpers/typeAliases.js\nvar init_typeAliases = __esm({\n  \"node_modules/zod/dist/esm/v3/helpers/typeAliases.js\"() {\n  }\n});\n\n// node_modules/zod/dist/esm/v3/helpers/errorUtil.js\nvar errorUtil;\nvar init_errorUtil = __esm({\n  \"node_modules/zod/dist/esm/v3/helpers/errorUtil.js\"() {\n    (function(errorUtil2) {\n      errorUtil2.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n      errorUtil2.toString = (message) => typeof message === \"string\" ? message : message?.message;\n    })(errorUtil || (errorUtil = {}));\n  }\n});\n\n// node_modules/zod/dist/esm/v3/types.js\nfunction processCreateParams(params) {\n  if (!params)\n    return {};\n  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;\n  if (errorMap2 && (invalid_type_error || required_error)) {\n    throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n  }\n  if (errorMap2)\n    return { errorMap: errorMap2, description };\n  const customMap = /* @__PURE__ */ __name((iss, ctx) => {\n    const { message } = params;\n    if (iss.code === \"invalid_enum_value\") {\n      return { message: message ?? ctx.defaultError };\n    }\n    if (typeof ctx.data === \"undefined\") {\n      return { message: message ?? required_error ?? ctx.defaultError };\n    }\n    if (iss.code !== \"invalid_type\")\n      return { message: ctx.defaultError };\n    return { message: message ?? invalid_type_error ?? ctx.defaultError };\n  }, \"customMap\");\n  return { errorMap: customMap, description };\n}\nfunction timeRegexSource(args) {\n  let secondsRegexSource = `[0-5]\\\\d`;\n  if (args.precision) {\n    secondsRegexSource = `${secondsRegexSource}\\\\.\\\\d{${args.precision}}`;\n  } else if (args.precision == null) {\n    secondsRegexSource = `${secondsRegexSource}(\\\\.\\\\d+)?`;\n  }\n  const secondsQuantifier = args.precision ? \"+\" : \"?\";\n  return `([01]\\\\d|2[0-3]):[0-5]\\\\d(:${secondsRegexSource})${secondsQuantifier}`;\n}\nfunction timeRegex(args) {\n  return new RegExp(`^${timeRegexSource(args)}$`);\n}\nfunction datetimeRegex(args) {\n  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n  const opts = [];\n  opts.push(args.local ? `Z?` : `Z`);\n  if (args.offset)\n    opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n  regex = `${regex}(${opts.join(\"|\")})`;\n  return new RegExp(`^${regex}$`);\n}\nfunction isValidIP(ip, version) {\n  if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n    return true;\n  }\n  if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n    return true;\n  }\n  return false;\n}\nfunction isValidJWT(jwt, alg) {\n  if (!jwtRegex.test(jwt))\n    return false;\n  try {\n    const [header] = jwt.split(\".\");\n    const base64 = header.replace(/-/g, \"+\").replace(/_/g, \"/\").padEnd(header.length + (4 - header.length % 4) % 4, \"=\");\n    const decoded = JSON.parse(atob(base64));\n    if (typeof decoded !== \"object\" || decoded === null)\n      return false;\n    if (\"typ\" in decoded && decoded?.typ !== \"JWT\")\n      return false;\n    if (!decoded.alg)\n      return false;\n    if (alg && decoded.alg !== alg)\n      return false;\n    return true;\n  } catch {\n    return false;\n  }\n}\nfunction isValidCidr(ip, version) {\n  if ((version === \"v4\" || !version) && ipv4CidrRegex.test(ip)) {\n    return true;\n  }\n  if ((version === \"v6\" || !version) && ipv6CidrRegex.test(ip)) {\n    return true;\n  }\n  return false;\n}\nfunction floatSafeRemainder(val, step) {\n  const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n  const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n  const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n  const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n  return valInt % stepInt / 10 ** decCount;\n}\nfunction deepPartialify(schema) {\n  if (schema instanceof ZodObject) {\n    const newShape = {};\n    for (const key in schema.shape) {\n      const fieldSchema = schema.shape[key];\n      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n    }\n    return new ZodObject({\n      ...schema._def,\n      shape: /* @__PURE__ */ __name(() => newShape, \"shape\")\n    });\n  } else if (schema instanceof ZodArray) {\n    return new ZodArray({\n      ...schema._def,\n      type: deepPartialify(schema.element)\n    });\n  } else if (schema instanceof ZodOptional) {\n    return ZodOptional.create(deepPartialify(schema.unwrap()));\n  } else if (schema instanceof ZodNullable) {\n    return ZodNullable.create(deepPartialify(schema.unwrap()));\n  } else if (schema instanceof ZodTuple) {\n    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n  } else {\n    return schema;\n  }\n}\nfunction mergeValues(a, b) {\n  const aType = getParsedType(a);\n  const bType = getParsedType(b);\n  if (a === b) {\n    return { valid: true, data: a };\n  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n    const bKeys = util.objectKeys(b);\n    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);\n    const newObj = { ...a, ...b };\n    for (const key of sharedKeys) {\n      const sharedValue = mergeValues(a[key], b[key]);\n      if (!sharedValue.valid) {\n        return { valid: false };\n      }\n      newObj[key] = sharedValue.data;\n    }\n    return { valid: true, data: newObj };\n  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n    if (a.length !== b.length) {\n      return { valid: false };\n    }\n    const newArray = [];\n    for (let index = 0; index < a.length; index++) {\n      const itemA = a[index];\n      const itemB = b[index];\n      const sharedValue = mergeValues(itemA, itemB);\n      if (!sharedValue.valid) {\n        return { valid: false };\n      }\n      newArray.push(sharedValue.data);\n    }\n    return { valid: true, data: newArray };\n  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {\n    return { valid: true, data: a };\n  } else {\n    return { valid: false };\n  }\n}\nfunction createZodEnum(values, params) {\n  return new ZodEnum({\n    values,\n    typeName: ZodFirstPartyTypeKind.ZodEnum,\n    ...processCreateParams(params)\n  });\n}\nfunction cleanParams(params, data) {\n  const p = typeof params === \"function\" ? params(data) : typeof params === \"string\" ? { message: params } : params;\n  const p2 = typeof p === \"string\" ? { message: p } : p;\n  return p2;\n}\nfunction custom(check, _params = {}, fatal) {\n  if (check)\n    return ZodAny.create().superRefine((data, ctx) => {\n      const r = check(data);\n      if (r instanceof Promise) {\n        return r.then((r2) => {\n          if (!r2) {\n            const params = cleanParams(_params, data);\n            const _fatal = params.fatal ?? fatal ?? true;\n            ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n          }\n        });\n      }\n      if (!r) {\n        const params = cleanParams(_params, data);\n        const _fatal = params.fatal ?? fatal ?? true;\n        ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n      }\n      return;\n    });\n  return ZodAny.create();\n}\nvar ParseInputLazyPath, handleResult, ZodType, cuidRegex, cuid2Regex, ulidRegex, uuidRegex, nanoidRegex, jwtRegex, durationRegex, emailRegex, _emojiRegex, emojiRegex, ipv4Regex, ipv4CidrRegex, ipv6Regex, ipv6CidrRegex, base64Regex, base64urlRegex, dateRegexSource, dateRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, ZodObject, ZodUnion, getDiscriminator, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, BRAND, ZodBranded, ZodPipeline, ZodReadonly, late, ZodFirstPartyTypeKind, instanceOfType, stringType, numberType, nanType, bigIntType, booleanType, dateType, symbolType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, pipelineType, ostring, onumber, oboolean, coerce, NEVER;\nvar init_types = __esm({\n  \"node_modules/zod/dist/esm/v3/types.js\"() {\n    init_ZodError();\n    init_errors();\n    init_errorUtil();\n    init_parseUtil();\n    init_util();\n    ParseInputLazyPath = class {\n      static {\n        __name(this, \"ParseInputLazyPath\");\n      }\n      constructor(parent, value, path, key) {\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n      }\n      get path() {\n        if (!this._cachedPath.length) {\n          if (Array.isArray(this._key)) {\n            this._cachedPath.push(...this._path, ...this._key);\n          } else {\n            this._cachedPath.push(...this._path, this._key);\n          }\n        }\n        return this._cachedPath;\n      }\n    };\n    handleResult = /* @__PURE__ */ __name((ctx, result) => {\n      if (isValid(result)) {\n        return { success: true, data: result.value };\n      } else {\n        if (!ctx.common.issues.length) {\n          throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n          success: false,\n          get error() {\n            if (this._error)\n              return this._error;\n            const error = new ZodError(ctx.common.issues);\n            this._error = error;\n            return this._error;\n          }\n        };\n      }\n    }, \"handleResult\");\n    __name(processCreateParams, \"processCreateParams\");\n    ZodType = class {\n      static {\n        __name(this, \"ZodType\");\n      }\n      get description() {\n        return this._def.description;\n      }\n      _getType(input) {\n        return getParsedType(input.data);\n      }\n      _getOrReturnCtx(input, ctx) {\n        return ctx || {\n          common: input.parent.common,\n          data: input.data,\n          parsedType: getParsedType(input.data),\n          schemaErrorMap: this._def.errorMap,\n          path: input.path,\n          parent: input.parent\n        };\n      }\n      _processInputParams(input) {\n        return {\n          status: new ParseStatus(),\n          ctx: {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: getParsedType(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent\n          }\n        };\n      }\n      _parseSync(input) {\n        const result = this._parse(input);\n        if (isAsync(result)) {\n          throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n      }\n      _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n      }\n      parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success)\n          return result.data;\n        throw result.error;\n      }\n      safeParse(data, params) {\n        const ctx = {\n          common: {\n            issues: [],\n            async: params?.async ?? false,\n            contextualErrorMap: params?.errorMap\n          },\n          path: params?.path || [],\n          schemaErrorMap: this._def.errorMap,\n          parent: null,\n          data,\n          parsedType: getParsedType(data)\n        };\n        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n        return handleResult(ctx, result);\n      }\n      \"~validate\"(data) {\n        const ctx = {\n          common: {\n            issues: [],\n            async: !!this[\"~standard\"].async\n          },\n          path: [],\n          schemaErrorMap: this._def.errorMap,\n          parent: null,\n          data,\n          parsedType: getParsedType(data)\n        };\n        if (!this[\"~standard\"].async) {\n          try {\n            const result = this._parseSync({ data, path: [], parent: ctx });\n            return isValid(result) ? {\n              value: result.value\n            } : {\n              issues: ctx.common.issues\n            };\n          } catch (err) {\n            if (err?.message?.toLowerCase()?.includes(\"encountered\")) {\n              this[\"~standard\"].async = true;\n            }\n            ctx.common = {\n              issues: [],\n              async: true\n            };\n          }\n        }\n        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {\n          value: result.value\n        } : {\n          issues: ctx.common.issues\n        });\n      }\n      async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success)\n          return result.data;\n        throw result.error;\n      }\n      async safeParseAsync(data, params) {\n        const ctx = {\n          common: {\n            issues: [],\n            contextualErrorMap: params?.errorMap,\n            async: true\n          },\n          path: params?.path || [],\n          schemaErrorMap: this._def.errorMap,\n          parent: null,\n          data,\n          parsedType: getParsedType(data)\n        };\n        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n      }\n      refine(check, message) {\n        const getIssueProperties = /* @__PURE__ */ __name((val) => {\n          if (typeof message === \"string\" || typeof message === \"undefined\") {\n            return { message };\n          } else if (typeof message === \"function\") {\n            return message(val);\n          } else {\n            return message;\n          }\n        }, \"getIssueProperties\");\n        return this._refinement((val, ctx) => {\n          const result = check(val);\n          const setError = /* @__PURE__ */ __name(() => ctx.addIssue({\n            code: ZodIssueCode.custom,\n            ...getIssueProperties(val)\n          }), \"setError\");\n          if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n            return result.then((data) => {\n              if (!data) {\n                setError();\n                return false;\n              } else {\n                return true;\n              }\n            });\n          }\n          if (!result) {\n            setError();\n            return false;\n          } else {\n            return true;\n          }\n        });\n      }\n      refinement(check, refinementData) {\n        return this._refinement((val, ctx) => {\n          if (!check(val)) {\n            ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n            return false;\n          } else {\n            return true;\n          }\n        });\n      }\n      _refinement(refinement) {\n        return new ZodEffects({\n          schema: this,\n          typeName: ZodFirstPartyTypeKind.ZodEffects,\n          effect: { type: \"refinement\", refinement }\n        });\n      }\n      superRefine(refinement) {\n        return this._refinement(refinement);\n      }\n      constructor(def) {\n        this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.readonly = this.readonly.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n        this[\"~standard\"] = {\n          version: 1,\n          vendor: \"zod\",\n          validate: /* @__PURE__ */ __name((data) => this[\"~validate\"](data), \"validate\")\n        };\n      }\n      optional() {\n        return ZodOptional.create(this, this._def);\n      }\n      nullable() {\n        return ZodNullable.create(this, this._def);\n      }\n      nullish() {\n        return this.nullable().optional();\n      }\n      array() {\n        return ZodArray.create(this);\n      }\n      promise() {\n        return ZodPromise.create(this, this._def);\n      }\n      or(option) {\n        return ZodUnion.create([this, option], this._def);\n      }\n      and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n      }\n      transform(transform) {\n        return new ZodEffects({\n          ...processCreateParams(this._def),\n          schema: this,\n          typeName: ZodFirstPartyTypeKind.ZodEffects,\n          effect: { type: \"transform\", transform }\n        });\n      }\n      default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodDefault({\n          ...processCreateParams(this._def),\n          innerType: this,\n          defaultValue: defaultValueFunc,\n          typeName: ZodFirstPartyTypeKind.ZodDefault\n        });\n      }\n      brand() {\n        return new ZodBranded({\n          typeName: ZodFirstPartyTypeKind.ZodBranded,\n          type: this,\n          ...processCreateParams(this._def)\n        });\n      }\n      catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodCatch({\n          ...processCreateParams(this._def),\n          innerType: this,\n          catchValue: catchValueFunc,\n          typeName: ZodFirstPartyTypeKind.ZodCatch\n        });\n      }\n      describe(description) {\n        const This = this.constructor;\n        return new This({\n          ...this._def,\n          description\n        });\n      }\n      pipe(target) {\n        return ZodPipeline.create(this, target);\n      }\n      readonly() {\n        return ZodReadonly.create(this);\n      }\n      isOptional() {\n        return this.safeParse(void 0).success;\n      }\n      isNullable() {\n        return this.safeParse(null).success;\n      }\n    };\n    cuidRegex = /^c[^\\s-]{8,}$/i;\n    cuid2Regex = /^[0-9a-z]+$/;\n    ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;\n    uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\n    nanoidRegex = /^[a-z0-9_-]{21}$/i;\n    jwtRegex = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/;\n    durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\n    emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\n    _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\n    ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\n    ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/;\n    ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;\n    ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\n    base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\n    base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;\n    dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\n    dateRegex = new RegExp(`^${dateRegexSource}$`);\n    __name(timeRegexSource, \"timeRegexSource\");\n    __name(timeRegex, \"timeRegex\");\n    __name(datetimeRegex, \"datetimeRegex\");\n    __name(isValidIP, \"isValidIP\");\n    __name(isValidJWT, \"isValidJWT\");\n    __name(isValidCidr, \"isValidCidr\");\n    ZodString = class _ZodString extends ZodType {\n      static {\n        __name(this, \"ZodString\");\n      }\n      _parse(input) {\n        if (this._def.coerce) {\n          input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.string) {\n          const ctx2 = this._getOrReturnCtx(input);\n          addIssueToContext(ctx2, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.string,\n            received: ctx2.parsedType\n          });\n          return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = void 0;\n        for (const check of this._def.checks) {\n          if (check.kind === \"min\") {\n            if (input.data.length < check.value) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                minimum: check.value,\n                type: \"string\",\n                inclusive: true,\n                exact: false,\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"max\") {\n            if (input.data.length > check.value) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                maximum: check.value,\n                type: \"string\",\n                inclusive: true,\n                exact: false,\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"length\") {\n            const tooBig = input.data.length > check.value;\n            const tooSmall = input.data.length < check.value;\n            if (tooBig || tooSmall) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              if (tooBig) {\n                addIssueToContext(ctx, {\n                  code: ZodIssueCode.too_big,\n                  maximum: check.value,\n                  type: \"string\",\n                  inclusive: true,\n                  exact: true,\n                  message: check.message\n                });\n              } else if (tooSmall) {\n                addIssueToContext(ctx, {\n                  code: ZodIssueCode.too_small,\n                  minimum: check.value,\n                  type: \"string\",\n                  inclusive: true,\n                  exact: true,\n                  message: check.message\n                });\n              }\n              status.dirty();\n            }\n          } else if (check.kind === \"email\") {\n            if (!emailRegex.test(input.data)) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                validation: \"email\",\n                code: ZodIssueCode.invalid_string,\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"emoji\") {\n            if (!emojiRegex) {\n              emojiRegex = new RegExp(_emojiRegex, \"u\");\n            }\n            if (!emojiRegex.test(input.data)) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                validation: \"emoji\",\n                code: ZodIssueCode.invalid_string,\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"uuid\") {\n            if (!uuidRegex.test(input.data)) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                validation: \"uuid\",\n                code: ZodIssueCode.invalid_string,\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"nanoid\") {\n            if (!nanoidRegex.test(input.data)) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                validation: \"nanoid\",\n                code: ZodIssueCode.invalid_string,\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"cuid\") {\n            if (!cuidRegex.test(input.data)) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                validation: \"cuid\",\n                code: ZodIssueCode.invalid_string,\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"cuid2\") {\n            if (!cuid2Regex.test(input.data)) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                validation: \"cuid2\",\n                code: ZodIssueCode.invalid_string,\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"ulid\") {\n            if (!ulidRegex.test(input.data)) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                validation: \"ulid\",\n                code: ZodIssueCode.invalid_string,\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"url\") {\n            try {\n              new URL(input.data);\n            } catch {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                validation: \"url\",\n                code: ZodIssueCode.invalid_string,\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"regex\") {\n            check.regex.lastIndex = 0;\n            const testResult = check.regex.test(input.data);\n            if (!testResult) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                validation: \"regex\",\n                code: ZodIssueCode.invalid_string,\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"trim\") {\n            input.data = input.data.trim();\n          } else if (check.kind === \"includes\") {\n            if (!input.data.includes(check.value, check.position)) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_string,\n                validation: { includes: check.value, position: check.position },\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"toLowerCase\") {\n            input.data = input.data.toLowerCase();\n          } else if (check.kind === \"toUpperCase\") {\n            input.data = input.data.toUpperCase();\n          } else if (check.kind === \"startsWith\") {\n            if (!input.data.startsWith(check.value)) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_string,\n                validation: { startsWith: check.value },\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"endsWith\") {\n            if (!input.data.endsWith(check.value)) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_string,\n                validation: { endsWith: check.value },\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"datetime\") {\n            const regex = datetimeRegex(check);\n            if (!regex.test(input.data)) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_string,\n                validation: \"datetime\",\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"date\") {\n            const regex = dateRegex;\n            if (!regex.test(input.data)) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_string,\n                validation: \"date\",\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"time\") {\n            const regex = timeRegex(check);\n            if (!regex.test(input.data)) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_string,\n                validation: \"time\",\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"duration\") {\n            if (!durationRegex.test(input.data)) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                validation: \"duration\",\n                code: ZodIssueCode.invalid_string,\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"ip\") {\n            if (!isValidIP(input.data, check.version)) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                validation: \"ip\",\n                code: ZodIssueCode.invalid_string,\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"jwt\") {\n            if (!isValidJWT(input.data, check.alg)) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                validation: \"jwt\",\n                code: ZodIssueCode.invalid_string,\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"cidr\") {\n            if (!isValidCidr(input.data, check.version)) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                validation: \"cidr\",\n                code: ZodIssueCode.invalid_string,\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"base64\") {\n            if (!base64Regex.test(input.data)) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                validation: \"base64\",\n                code: ZodIssueCode.invalid_string,\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"base64url\") {\n            if (!base64urlRegex.test(input.data)) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                validation: \"base64url\",\n                code: ZodIssueCode.invalid_string,\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else {\n            util.assertNever(check);\n          }\n        }\n        return { status: status.value, value: input.data };\n      }\n      _regex(regex, validation, message) {\n        return this.refinement((data) => regex.test(data), {\n          validation,\n          code: ZodIssueCode.invalid_string,\n          ...errorUtil.errToObj(message)\n        });\n      }\n      _addCheck(check) {\n        return new _ZodString({\n          ...this._def,\n          checks: [...this._def.checks, check]\n        });\n      }\n      email(message) {\n        return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n      }\n      url(message) {\n        return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n      }\n      emoji(message) {\n        return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\n      }\n      uuid(message) {\n        return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n      }\n      nanoid(message) {\n        return this._addCheck({ kind: \"nanoid\", ...errorUtil.errToObj(message) });\n      }\n      cuid(message) {\n        return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n      }\n      cuid2(message) {\n        return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\n      }\n      ulid(message) {\n        return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\n      }\n      base64(message) {\n        return this._addCheck({ kind: \"base64\", ...errorUtil.errToObj(message) });\n      }\n      base64url(message) {\n        return this._addCheck({\n          kind: \"base64url\",\n          ...errorUtil.errToObj(message)\n        });\n      }\n      jwt(options) {\n        return this._addCheck({ kind: \"jwt\", ...errorUtil.errToObj(options) });\n      }\n      ip(options) {\n        return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\n      }\n      cidr(options) {\n        return this._addCheck({ kind: \"cidr\", ...errorUtil.errToObj(options) });\n      }\n      datetime(options) {\n        if (typeof options === \"string\") {\n          return this._addCheck({\n            kind: \"datetime\",\n            precision: null,\n            offset: false,\n            local: false,\n            message: options\n          });\n        }\n        return this._addCheck({\n          kind: \"datetime\",\n          precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n          offset: options?.offset ?? false,\n          local: options?.local ?? false,\n          ...errorUtil.errToObj(options?.message)\n        });\n      }\n      date(message) {\n        return this._addCheck({ kind: \"date\", message });\n      }\n      time(options) {\n        if (typeof options === \"string\") {\n          return this._addCheck({\n            kind: \"time\",\n            precision: null,\n            message: options\n          });\n        }\n        return this._addCheck({\n          kind: \"time\",\n          precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n          ...errorUtil.errToObj(options?.message)\n        });\n      }\n      duration(message) {\n        return this._addCheck({ kind: \"duration\", ...errorUtil.errToObj(message) });\n      }\n      regex(regex, message) {\n        return this._addCheck({\n          kind: \"regex\",\n          regex,\n          ...errorUtil.errToObj(message)\n        });\n      }\n      includes(value, options) {\n        return this._addCheck({\n          kind: \"includes\",\n          value,\n          position: options?.position,\n          ...errorUtil.errToObj(options?.message)\n        });\n      }\n      startsWith(value, message) {\n        return this._addCheck({\n          kind: \"startsWith\",\n          value,\n          ...errorUtil.errToObj(message)\n        });\n      }\n      endsWith(value, message) {\n        return this._addCheck({\n          kind: \"endsWith\",\n          value,\n          ...errorUtil.errToObj(message)\n        });\n      }\n      min(minLength, message) {\n        return this._addCheck({\n          kind: \"min\",\n          value: minLength,\n          ...errorUtil.errToObj(message)\n        });\n      }\n      max(maxLength, message) {\n        return this._addCheck({\n          kind: \"max\",\n          value: maxLength,\n          ...errorUtil.errToObj(message)\n        });\n      }\n      length(len, message) {\n        return this._addCheck({\n          kind: \"length\",\n          value: len,\n          ...errorUtil.errToObj(message)\n        });\n      }\n      /**\n       * Equivalent to `.min(1)`\n       */\n      nonempty(message) {\n        return this.min(1, errorUtil.errToObj(message));\n      }\n      trim() {\n        return new _ZodString({\n          ...this._def,\n          checks: [...this._def.checks, { kind: \"trim\" }]\n        });\n      }\n      toLowerCase() {\n        return new _ZodString({\n          ...this._def,\n          checks: [...this._def.checks, { kind: \"toLowerCase\" }]\n        });\n      }\n      toUpperCase() {\n        return new _ZodString({\n          ...this._def,\n          checks: [...this._def.checks, { kind: \"toUpperCase\" }]\n        });\n      }\n      get isDatetime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n      }\n      get isDate() {\n        return !!this._def.checks.find((ch) => ch.kind === \"date\");\n      }\n      get isTime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"time\");\n      }\n      get isDuration() {\n        return !!this._def.checks.find((ch) => ch.kind === \"duration\");\n      }\n      get isEmail() {\n        return !!this._def.checks.find((ch) => ch.kind === \"email\");\n      }\n      get isURL() {\n        return !!this._def.checks.find((ch) => ch.kind === \"url\");\n      }\n      get isEmoji() {\n        return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n      }\n      get isUUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n      }\n      get isNANOID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"nanoid\");\n      }\n      get isCUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n      }\n      get isCUID2() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n      }\n      get isULID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n      }\n      get isIP() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n      }\n      get isCIDR() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cidr\");\n      }\n      get isBase64() {\n        return !!this._def.checks.find((ch) => ch.kind === \"base64\");\n      }\n      get isBase64url() {\n        return !!this._def.checks.find((ch) => ch.kind === \"base64url\");\n      }\n      get minLength() {\n        let min = null;\n        for (const ch of this._def.checks) {\n          if (ch.kind === \"min\") {\n            if (min === null || ch.value > min)\n              min = ch.value;\n          }\n        }\n        return min;\n      }\n      get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks) {\n          if (ch.kind === \"max\") {\n            if (max === null || ch.value < max)\n              max = ch.value;\n          }\n        }\n        return max;\n      }\n    };\n    ZodString.create = (params) => {\n      return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params)\n      });\n    };\n    __name(floatSafeRemainder, \"floatSafeRemainder\");\n    ZodNumber = class _ZodNumber extends ZodType {\n      static {\n        __name(this, \"ZodNumber\");\n      }\n      constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n      }\n      _parse(input) {\n        if (this._def.coerce) {\n          input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.number) {\n          const ctx2 = this._getOrReturnCtx(input);\n          addIssueToContext(ctx2, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.number,\n            received: ctx2.parsedType\n          });\n          return INVALID;\n        }\n        let ctx = void 0;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n          if (check.kind === \"int\") {\n            if (!util.isInteger(input.data)) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: \"integer\",\n                received: \"float\",\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"min\") {\n            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n            if (tooSmall) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                minimum: check.value,\n                type: \"number\",\n                inclusive: check.inclusive,\n                exact: false,\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"max\") {\n            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n            if (tooBig) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                maximum: check.value,\n                type: \"number\",\n                inclusive: check.inclusive,\n                exact: false,\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"multipleOf\") {\n            if (floatSafeRemainder(input.data, check.value) !== 0) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                code: ZodIssueCode.not_multiple_of,\n                multipleOf: check.value,\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"finite\") {\n            if (!Number.isFinite(input.data)) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                code: ZodIssueCode.not_finite,\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else {\n            util.assertNever(check);\n          }\n        }\n        return { status: status.value, value: input.data };\n      }\n      gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n      }\n      gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n      }\n      lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n      }\n      lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n      }\n      setLimit(kind, value, inclusive, message) {\n        return new _ZodNumber({\n          ...this._def,\n          checks: [\n            ...this._def.checks,\n            {\n              kind,\n              value,\n              inclusive,\n              message: errorUtil.toString(message)\n            }\n          ]\n        });\n      }\n      _addCheck(check) {\n        return new _ZodNumber({\n          ...this._def,\n          checks: [...this._def.checks, check]\n        });\n      }\n      int(message) {\n        return this._addCheck({\n          kind: \"int\",\n          message: errorUtil.toString(message)\n        });\n      }\n      positive(message) {\n        return this._addCheck({\n          kind: \"min\",\n          value: 0,\n          inclusive: false,\n          message: errorUtil.toString(message)\n        });\n      }\n      negative(message) {\n        return this._addCheck({\n          kind: \"max\",\n          value: 0,\n          inclusive: false,\n          message: errorUtil.toString(message)\n        });\n      }\n      nonpositive(message) {\n        return this._addCheck({\n          kind: \"max\",\n          value: 0,\n          inclusive: true,\n          message: errorUtil.toString(message)\n        });\n      }\n      nonnegative(message) {\n        return this._addCheck({\n          kind: \"min\",\n          value: 0,\n          inclusive: true,\n          message: errorUtil.toString(message)\n        });\n      }\n      multipleOf(value, message) {\n        return this._addCheck({\n          kind: \"multipleOf\",\n          value,\n          message: errorUtil.toString(message)\n        });\n      }\n      finite(message) {\n        return this._addCheck({\n          kind: \"finite\",\n          message: errorUtil.toString(message)\n        });\n      }\n      safe(message) {\n        return this._addCheck({\n          kind: \"min\",\n          inclusive: true,\n          value: Number.MIN_SAFE_INTEGER,\n          message: errorUtil.toString(message)\n        })._addCheck({\n          kind: \"max\",\n          inclusive: true,\n          value: Number.MAX_SAFE_INTEGER,\n          message: errorUtil.toString(message)\n        });\n      }\n      get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n          if (ch.kind === \"min\") {\n            if (min === null || ch.value > min)\n              min = ch.value;\n          }\n        }\n        return min;\n      }\n      get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n          if (ch.kind === \"max\") {\n            if (max === null || ch.value < max)\n              max = ch.value;\n          }\n        }\n        return max;\n      }\n      get isInt() {\n        return !!this._def.checks.find((ch) => ch.kind === \"int\" || ch.kind === \"multipleOf\" && util.isInteger(ch.value));\n      }\n      get isFinite() {\n        let max = null;\n        let min = null;\n        for (const ch of this._def.checks) {\n          if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\") {\n            return true;\n          } else if (ch.kind === \"min\") {\n            if (min === null || ch.value > min)\n              min = ch.value;\n          } else if (ch.kind === \"max\") {\n            if (max === null || ch.value < max)\n              max = ch.value;\n          }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n      }\n    };\n    ZodNumber.create = (params) => {\n      return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params)\n      });\n    };\n    ZodBigInt = class _ZodBigInt extends ZodType {\n      static {\n        __name(this, \"ZodBigInt\");\n      }\n      constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n      }\n      _parse(input) {\n        if (this._def.coerce) {\n          try {\n            input.data = BigInt(input.data);\n          } catch {\n            return this._getInvalidInput(input);\n          }\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.bigint) {\n          return this._getInvalidInput(input);\n        }\n        let ctx = void 0;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n          if (check.kind === \"min\") {\n            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n            if (tooSmall) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                type: \"bigint\",\n                minimum: check.value,\n                inclusive: check.inclusive,\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"max\") {\n            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n            if (tooBig) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                type: \"bigint\",\n                maximum: check.value,\n                inclusive: check.inclusive,\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"multipleOf\") {\n            if (input.data % check.value !== BigInt(0)) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                code: ZodIssueCode.not_multiple_of,\n                multipleOf: check.value,\n                message: check.message\n              });\n              status.dirty();\n            }\n          } else {\n            util.assertNever(check);\n          }\n        }\n        return { status: status.value, value: input.data };\n      }\n      _getInvalidInput(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.invalid_type,\n          expected: ZodParsedType.bigint,\n          received: ctx.parsedType\n        });\n        return INVALID;\n      }\n      gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n      }\n      gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n      }\n      lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n      }\n      lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n      }\n      setLimit(kind, value, inclusive, message) {\n        return new _ZodBigInt({\n          ...this._def,\n          checks: [\n            ...this._def.checks,\n            {\n              kind,\n              value,\n              inclusive,\n              message: errorUtil.toString(message)\n            }\n          ]\n        });\n      }\n      _addCheck(check) {\n        return new _ZodBigInt({\n          ...this._def,\n          checks: [...this._def.checks, check]\n        });\n      }\n      positive(message) {\n        return this._addCheck({\n          kind: \"min\",\n          value: BigInt(0),\n          inclusive: false,\n          message: errorUtil.toString(message)\n        });\n      }\n      negative(message) {\n        return this._addCheck({\n          kind: \"max\",\n          value: BigInt(0),\n          inclusive: false,\n          message: errorUtil.toString(message)\n        });\n      }\n      nonpositive(message) {\n        return this._addCheck({\n          kind: \"max\",\n          value: BigInt(0),\n          inclusive: true,\n          message: errorUtil.toString(message)\n        });\n      }\n      nonnegative(message) {\n        return this._addCheck({\n          kind: \"min\",\n          value: BigInt(0),\n          inclusive: true,\n          message: errorUtil.toString(message)\n        });\n      }\n      multipleOf(value, message) {\n        return this._addCheck({\n          kind: \"multipleOf\",\n          value,\n          message: errorUtil.toString(message)\n        });\n      }\n      get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n          if (ch.kind === \"min\") {\n            if (min === null || ch.value > min)\n              min = ch.value;\n          }\n        }\n        return min;\n      }\n      get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n          if (ch.kind === \"max\") {\n            if (max === null || ch.value < max)\n              max = ch.value;\n          }\n        }\n        return max;\n      }\n    };\n    ZodBigInt.create = (params) => {\n      return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params)\n      });\n    };\n    ZodBoolean = class extends ZodType {\n      static {\n        __name(this, \"ZodBoolean\");\n      }\n      _parse(input) {\n        if (this._def.coerce) {\n          input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.boolean) {\n          const ctx = this._getOrReturnCtx(input);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.boolean,\n            received: ctx.parsedType\n          });\n          return INVALID;\n        }\n        return OK(input.data);\n      }\n    };\n    ZodBoolean.create = (params) => {\n      return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params)\n      });\n    };\n    ZodDate = class _ZodDate extends ZodType {\n      static {\n        __name(this, \"ZodDate\");\n      }\n      _parse(input) {\n        if (this._def.coerce) {\n          input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.date) {\n          const ctx2 = this._getOrReturnCtx(input);\n          addIssueToContext(ctx2, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.date,\n            received: ctx2.parsedType\n          });\n          return INVALID;\n        }\n        if (Number.isNaN(input.data.getTime())) {\n          const ctx2 = this._getOrReturnCtx(input);\n          addIssueToContext(ctx2, {\n            code: ZodIssueCode.invalid_date\n          });\n          return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = void 0;\n        for (const check of this._def.checks) {\n          if (check.kind === \"min\") {\n            if (input.data.getTime() < check.value) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                message: check.message,\n                inclusive: true,\n                exact: false,\n                minimum: check.value,\n                type: \"date\"\n              });\n              status.dirty();\n            }\n          } else if (check.kind === \"max\") {\n            if (input.data.getTime() > check.value) {\n              ctx = this._getOrReturnCtx(input, ctx);\n              addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                message: check.message,\n                inclusive: true,\n                exact: false,\n                maximum: check.value,\n                type: \"date\"\n              });\n              status.dirty();\n            }\n          } else {\n            util.assertNever(check);\n          }\n        }\n        return {\n          status: status.value,\n          value: new Date(input.data.getTime())\n        };\n      }\n      _addCheck(check) {\n        return new _ZodDate({\n          ...this._def,\n          checks: [...this._def.checks, check]\n        });\n      }\n      min(minDate, message) {\n        return this._addCheck({\n          kind: \"min\",\n          value: minDate.getTime(),\n          message: errorUtil.toString(message)\n        });\n      }\n      max(maxDate, message) {\n        return this._addCheck({\n          kind: \"max\",\n          value: maxDate.getTime(),\n          message: errorUtil.toString(message)\n        });\n      }\n      get minDate() {\n        let min = null;\n        for (const ch of this._def.checks) {\n          if (ch.kind === \"min\") {\n            if (min === null || ch.value > min)\n              min = ch.value;\n          }\n        }\n        return min != null ? new Date(min) : null;\n      }\n      get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks) {\n          if (ch.kind === \"max\") {\n            if (max === null || ch.value < max)\n              max = ch.value;\n          }\n        }\n        return max != null ? new Date(max) : null;\n      }\n    };\n    ZodDate.create = (params) => {\n      return new ZodDate({\n        checks: [],\n        coerce: params?.coerce || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params)\n      });\n    };\n    ZodSymbol = class extends ZodType {\n      static {\n        __name(this, \"ZodSymbol\");\n      }\n      _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.symbol) {\n          const ctx = this._getOrReturnCtx(input);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.symbol,\n            received: ctx.parsedType\n          });\n          return INVALID;\n        }\n        return OK(input.data);\n      }\n    };\n    ZodSymbol.create = (params) => {\n      return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params)\n      });\n    };\n    ZodUndefined = class extends ZodType {\n      static {\n        __name(this, \"ZodUndefined\");\n      }\n      _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n          const ctx = this._getOrReturnCtx(input);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.undefined,\n            received: ctx.parsedType\n          });\n          return INVALID;\n        }\n        return OK(input.data);\n      }\n    };\n    ZodUndefined.create = (params) => {\n      return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params)\n      });\n    };\n    ZodNull = class extends ZodType {\n      static {\n        __name(this, \"ZodNull\");\n      }\n      _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.null) {\n          const ctx = this._getOrReturnCtx(input);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.null,\n            received: ctx.parsedType\n          });\n          return INVALID;\n        }\n        return OK(input.data);\n      }\n    };\n    ZodNull.create = (params) => {\n      return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params)\n      });\n    };\n    ZodAny = class extends ZodType {\n      static {\n        __name(this, \"ZodAny\");\n      }\n      constructor() {\n        super(...arguments);\n        this._any = true;\n      }\n      _parse(input) {\n        return OK(input.data);\n      }\n    };\n    ZodAny.create = (params) => {\n      return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params)\n      });\n    };\n    ZodUnknown = class extends ZodType {\n      static {\n        __name(this, \"ZodUnknown\");\n      }\n      constructor() {\n        super(...arguments);\n        this._unknown = true;\n      }\n      _parse(input) {\n        return OK(input.data);\n      }\n    };\n    ZodUnknown.create = (params) => {\n      return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params)\n      });\n    };\n    ZodNever = class extends ZodType {\n      static {\n        __name(this, \"ZodNever\");\n      }\n      _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.invalid_type,\n          expected: ZodParsedType.never,\n          received: ctx.parsedType\n        });\n        return INVALID;\n      }\n    };\n    ZodNever.create = (params) => {\n      return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params)\n      });\n    };\n    ZodVoid = class extends ZodType {\n      static {\n        __name(this, \"ZodVoid\");\n      }\n      _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n          const ctx = this._getOrReturnCtx(input);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.void,\n            received: ctx.parsedType\n          });\n          return INVALID;\n        }\n        return OK(input.data);\n      }\n    };\n    ZodVoid.create = (params) => {\n      return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params)\n      });\n    };\n    ZodArray = class _ZodArray extends ZodType {\n      static {\n        __name(this, \"ZodArray\");\n      }\n      _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== ZodParsedType.array) {\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.array,\n            received: ctx.parsedType\n          });\n          return INVALID;\n        }\n        if (def.exactLength !== null) {\n          const tooBig = ctx.data.length > def.exactLength.value;\n          const tooSmall = ctx.data.length < def.exactLength.value;\n          if (tooBig || tooSmall) {\n            addIssueToContext(ctx, {\n              code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n              minimum: tooSmall ? def.exactLength.value : void 0,\n              maximum: tooBig ? def.exactLength.value : void 0,\n              type: \"array\",\n              inclusive: true,\n              exact: true,\n              message: def.exactLength.message\n            });\n            status.dirty();\n          }\n        }\n        if (def.minLength !== null) {\n          if (ctx.data.length < def.minLength.value) {\n            addIssueToContext(ctx, {\n              code: ZodIssueCode.too_small,\n              minimum: def.minLength.value,\n              type: \"array\",\n              inclusive: true,\n              exact: false,\n              message: def.minLength.message\n            });\n            status.dirty();\n          }\n        }\n        if (def.maxLength !== null) {\n          if (ctx.data.length > def.maxLength.value) {\n            addIssueToContext(ctx, {\n              code: ZodIssueCode.too_big,\n              maximum: def.maxLength.value,\n              type: \"array\",\n              inclusive: true,\n              exact: false,\n              message: def.maxLength.message\n            });\n            status.dirty();\n          }\n        }\n        if (ctx.common.async) {\n          return Promise.all([...ctx.data].map((item, i) => {\n            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n          })).then((result2) => {\n            return ParseStatus.mergeArray(status, result2);\n          });\n        }\n        const result = [...ctx.data].map((item, i) => {\n          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return ParseStatus.mergeArray(status, result);\n      }\n      get element() {\n        return this._def.type;\n      }\n      min(minLength, message) {\n        return new _ZodArray({\n          ...this._def,\n          minLength: { value: minLength, message: errorUtil.toString(message) }\n        });\n      }\n      max(maxLength, message) {\n        return new _ZodArray({\n          ...this._def,\n          maxLength: { value: maxLength, message: errorUtil.toString(message) }\n        });\n      }\n      length(len, message) {\n        return new _ZodArray({\n          ...this._def,\n          exactLength: { value: len, message: errorUtil.toString(message) }\n        });\n      }\n      nonempty(message) {\n        return this.min(1, message);\n      }\n    };\n    ZodArray.create = (schema, params) => {\n      return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params)\n      });\n    };\n    __name(deepPartialify, \"deepPartialify\");\n    ZodObject = class _ZodObject extends ZodType {\n      static {\n        __name(this, \"ZodObject\");\n      }\n      constructor() {\n        super(...arguments);\n        this._cached = null;\n        this.nonstrict = this.passthrough;\n        this.augment = this.extend;\n      }\n      _getCached() {\n        if (this._cached !== null)\n          return this._cached;\n        const shape = this._def.shape();\n        const keys = util.objectKeys(shape);\n        this._cached = { shape, keys };\n        return this._cached;\n      }\n      _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.object) {\n          const ctx2 = this._getOrReturnCtx(input);\n          addIssueToContext(ctx2, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.object,\n            received: ctx2.parsedType\n          });\n          return INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n          for (const key in ctx.data) {\n            if (!shapeKeys.includes(key)) {\n              extraKeys.push(key);\n            }\n          }\n        }\n        const pairs = [];\n        for (const key of shapeKeys) {\n          const keyValidator = shape[key];\n          const value = ctx.data[key];\n          pairs.push({\n            key: { status: \"valid\", value: key },\n            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n            alwaysSet: key in ctx.data\n          });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n          const unknownKeys = this._def.unknownKeys;\n          if (unknownKeys === \"passthrough\") {\n            for (const key of extraKeys) {\n              pairs.push({\n                key: { status: \"valid\", value: key },\n                value: { status: \"valid\", value: ctx.data[key] }\n              });\n            }\n          } else if (unknownKeys === \"strict\") {\n            if (extraKeys.length > 0) {\n              addIssueToContext(ctx, {\n                code: ZodIssueCode.unrecognized_keys,\n                keys: extraKeys\n              });\n              status.dirty();\n            }\n          } else if (unknownKeys === \"strip\") {\n          } else {\n            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n          }\n        } else {\n          const catchall = this._def.catchall;\n          for (const key of extraKeys) {\n            const value = ctx.data[key];\n            pairs.push({\n              key: { status: \"valid\", value: key },\n              value: catchall._parse(\n                new ParseInputLazyPath(ctx, value, ctx.path, key)\n                //, ctx.child(key), value, getParsedType(value)\n              ),\n              alwaysSet: key in ctx.data\n            });\n          }\n        }\n        if (ctx.common.async) {\n          return Promise.resolve().then(async () => {\n            const syncPairs = [];\n            for (const pair of pairs) {\n              const key = await pair.key;\n              const value = await pair.value;\n              syncPairs.push({\n                key,\n                value,\n                alwaysSet: pair.alwaysSet\n              });\n            }\n            return syncPairs;\n          }).then((syncPairs) => {\n            return ParseStatus.mergeObjectSync(status, syncPairs);\n          });\n        } else {\n          return ParseStatus.mergeObjectSync(status, pairs);\n        }\n      }\n      get shape() {\n        return this._def.shape();\n      }\n      strict(message) {\n        errorUtil.errToObj;\n        return new _ZodObject({\n          ...this._def,\n          unknownKeys: \"strict\",\n          ...message !== void 0 ? {\n            errorMap: /* @__PURE__ */ __name((issue, ctx) => {\n              const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;\n              if (issue.code === \"unrecognized_keys\")\n                return {\n                  message: errorUtil.errToObj(message).message ?? defaultError\n                };\n              return {\n                message: defaultError\n              };\n            }, \"errorMap\")\n          } : {}\n        });\n      }\n      strip() {\n        return new _ZodObject({\n          ...this._def,\n          unknownKeys: \"strip\"\n        });\n      }\n      passthrough() {\n        return new _ZodObject({\n          ...this._def,\n          unknownKeys: \"passthrough\"\n        });\n      }\n      // const AugmentFactory =\n      //   <Def extends ZodObjectDef>(def: Def) =>\n      //   <Augmentation extends ZodRawShape>(\n      //     augmentation: Augmentation\n      //   ): ZodObject<\n      //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n      //     Def[\"unknownKeys\"],\n      //     Def[\"catchall\"]\n      //   > => {\n      //     return new ZodObject({\n      //       ...def,\n      //       shape: () => ({\n      //         ...def.shape(),\n      //         ...augmentation,\n      //       }),\n      //     }) as any;\n      //   };\n      extend(augmentation) {\n        return new _ZodObject({\n          ...this._def,\n          shape: /* @__PURE__ */ __name(() => ({\n            ...this._def.shape(),\n            ...augmentation\n          }), \"shape\")\n        });\n      }\n      /**\n       * Prior to zod@1.0.12 there was a bug in the\n       * inferred type of merged objects. Please\n       * upgrade if you are experiencing issues.\n       */\n      merge(merging) {\n        const merged = new _ZodObject({\n          unknownKeys: merging._def.unknownKeys,\n          catchall: merging._def.catchall,\n          shape: /* @__PURE__ */ __name(() => ({\n            ...this._def.shape(),\n            ...merging._def.shape()\n          }), \"shape\"),\n          typeName: ZodFirstPartyTypeKind.ZodObject\n        });\n        return merged;\n      }\n      // merge<\n      //   Incoming extends AnyZodObject,\n      //   Augmentation extends Incoming[\"shape\"],\n      //   NewOutput extends {\n      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n      //       ? Augmentation[k][\"_output\"]\n      //       : k extends keyof Output\n      //       ? Output[k]\n      //       : never;\n      //   },\n      //   NewInput extends {\n      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n      //       ? Augmentation[k][\"_input\"]\n      //       : k extends keyof Input\n      //       ? Input[k]\n      //       : never;\n      //   }\n      // >(\n      //   merging: Incoming\n      // ): ZodObject<\n      //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n      //   Incoming[\"_def\"][\"unknownKeys\"],\n      //   Incoming[\"_def\"][\"catchall\"],\n      //   NewOutput,\n      //   NewInput\n      // > {\n      //   const merged: any = new ZodObject({\n      //     unknownKeys: merging._def.unknownKeys,\n      //     catchall: merging._def.catchall,\n      //     shape: () =>\n      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n      //     typeName: ZodFirstPartyTypeKind.ZodObject,\n      //   }) as any;\n      //   return merged;\n      // }\n      setKey(key, schema) {\n        return this.augment({ [key]: schema });\n      }\n      // merge<Incoming extends AnyZodObject>(\n      //   merging: Incoming\n      // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n      // ZodObject<\n      //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n      //   Incoming[\"_def\"][\"unknownKeys\"],\n      //   Incoming[\"_def\"][\"catchall\"]\n      // > {\n      //   // const mergedShape = objectUtil.mergeShapes(\n      //   //   this._def.shape(),\n      //   //   merging._def.shape()\n      //   // );\n      //   const merged: any = new ZodObject({\n      //     unknownKeys: merging._def.unknownKeys,\n      //     catchall: merging._def.catchall,\n      //     shape: () =>\n      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n      //     typeName: ZodFirstPartyTypeKind.ZodObject,\n      //   }) as any;\n      //   return merged;\n      // }\n      catchall(index) {\n        return new _ZodObject({\n          ...this._def,\n          catchall: index\n        });\n      }\n      pick(mask) {\n        const shape = {};\n        for (const key of util.objectKeys(mask)) {\n          if (mask[key] && this.shape[key]) {\n            shape[key] = this.shape[key];\n          }\n        }\n        return new _ZodObject({\n          ...this._def,\n          shape: /* @__PURE__ */ __name(() => shape, \"shape\")\n        });\n      }\n      omit(mask) {\n        const shape = {};\n        for (const key of util.objectKeys(this.shape)) {\n          if (!mask[key]) {\n            shape[key] = this.shape[key];\n          }\n        }\n        return new _ZodObject({\n          ...this._def,\n          shape: /* @__PURE__ */ __name(() => shape, \"shape\")\n        });\n      }\n      /**\n       * @deprecated\n       */\n      deepPartial() {\n        return deepPartialify(this);\n      }\n      partial(mask) {\n        const newShape = {};\n        for (const key of util.objectKeys(this.shape)) {\n          const fieldSchema = this.shape[key];\n          if (mask && !mask[key]) {\n            newShape[key] = fieldSchema;\n          } else {\n            newShape[key] = fieldSchema.optional();\n          }\n        }\n        return new _ZodObject({\n          ...this._def,\n          shape: /* @__PURE__ */ __name(() => newShape, \"shape\")\n        });\n      }\n      required(mask) {\n        const newShape = {};\n        for (const key of util.objectKeys(this.shape)) {\n          if (mask && !mask[key]) {\n            newShape[key] = this.shape[key];\n          } else {\n            const fieldSchema = this.shape[key];\n            let newField = fieldSchema;\n            while (newField instanceof ZodOptional) {\n              newField = newField._def.innerType;\n            }\n            newShape[key] = newField;\n          }\n        }\n        return new _ZodObject({\n          ...this._def,\n          shape: /* @__PURE__ */ __name(() => newShape, \"shape\")\n        });\n      }\n      keyof() {\n        return createZodEnum(util.objectKeys(this.shape));\n      }\n    };\n    ZodObject.create = (shape, params) => {\n      return new ZodObject({\n        shape: /* @__PURE__ */ __name(() => shape, \"shape\"),\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params)\n      });\n    };\n    ZodObject.strictCreate = (shape, params) => {\n      return new ZodObject({\n        shape: /* @__PURE__ */ __name(() => shape, \"shape\"),\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params)\n      });\n    };\n    ZodObject.lazycreate = (shape, params) => {\n      return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params)\n      });\n    };\n    ZodUnion = class extends ZodType {\n      static {\n        __name(this, \"ZodUnion\");\n      }\n      _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n          for (const result of results) {\n            if (result.result.status === \"valid\") {\n              return result.result;\n            }\n          }\n          for (const result of results) {\n            if (result.result.status === \"dirty\") {\n              ctx.common.issues.push(...result.ctx.common.issues);\n              return result.result;\n            }\n          }\n          const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_union,\n            unionErrors\n          });\n          return INVALID;\n        }\n        __name(handleResults, \"handleResults\");\n        if (ctx.common.async) {\n          return Promise.all(options.map(async (option) => {\n            const childCtx = {\n              ...ctx,\n              common: {\n                ...ctx.common,\n                issues: []\n              },\n              parent: null\n            };\n            return {\n              result: await option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: childCtx\n              }),\n              ctx: childCtx\n            };\n          })).then(handleResults);\n        } else {\n          let dirty = void 0;\n          const issues = [];\n          for (const option of options) {\n            const childCtx = {\n              ...ctx,\n              common: {\n                ...ctx.common,\n                issues: []\n              },\n              parent: null\n            };\n            const result = option._parseSync({\n              data: ctx.data,\n              path: ctx.path,\n              parent: childCtx\n            });\n            if (result.status === \"valid\") {\n              return result;\n            } else if (result.status === \"dirty\" && !dirty) {\n              dirty = { result, ctx: childCtx };\n            }\n            if (childCtx.common.issues.length) {\n              issues.push(childCtx.common.issues);\n            }\n          }\n          if (dirty) {\n            ctx.common.issues.push(...dirty.ctx.common.issues);\n            return dirty.result;\n          }\n          const unionErrors = issues.map((issues2) => new ZodError(issues2));\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_union,\n            unionErrors\n          });\n          return INVALID;\n        }\n      }\n      get options() {\n        return this._def.options;\n      }\n    };\n    ZodUnion.create = (types, params) => {\n      return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params)\n      });\n    };\n    getDiscriminator = /* @__PURE__ */ __name((type) => {\n      if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n      } else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n      } else if (type instanceof ZodLiteral) {\n        return [type.value];\n      } else if (type instanceof ZodEnum) {\n        return type.options;\n      } else if (type instanceof ZodNativeEnum) {\n        return util.objectValues(type.enum);\n      } else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n      } else if (type instanceof ZodUndefined) {\n        return [void 0];\n      } else if (type instanceof ZodNull) {\n        return [null];\n      } else if (type instanceof ZodOptional) {\n        return [void 0, ...getDiscriminator(type.unwrap())];\n      } else if (type instanceof ZodNullable) {\n        return [null, ...getDiscriminator(type.unwrap())];\n      } else if (type instanceof ZodBranded) {\n        return getDiscriminator(type.unwrap());\n      } else if (type instanceof ZodReadonly) {\n        return getDiscriminator(type.unwrap());\n      } else if (type instanceof ZodCatch) {\n        return getDiscriminator(type._def.innerType);\n      } else {\n        return [];\n      }\n    }, \"getDiscriminator\");\n    ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {\n      static {\n        __name(this, \"ZodDiscriminatedUnion\");\n      }\n      _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.object,\n            received: ctx.parsedType\n          });\n          return INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_union_discriminator,\n            options: Array.from(this.optionsMap.keys()),\n            path: [discriminator]\n          });\n          return INVALID;\n        }\n        if (ctx.common.async) {\n          return option._parseAsync({\n            data: ctx.data,\n            path: ctx.path,\n            parent: ctx\n          });\n        } else {\n          return option._parseSync({\n            data: ctx.data,\n            path: ctx.path,\n            parent: ctx\n          });\n        }\n      }\n      get discriminator() {\n        return this._def.discriminator;\n      }\n      get options() {\n        return this._def.options;\n      }\n      get optionsMap() {\n        return this._def.optionsMap;\n      }\n      /**\n       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n       * have a different value for each object in the union.\n       * @param discriminator the name of the discriminator property\n       * @param types an array of object schemas\n       * @param params\n       */\n      static create(discriminator, options, params) {\n        const optionsMap = /* @__PURE__ */ new Map();\n        for (const type of options) {\n          const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n          if (!discriminatorValues.length) {\n            throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n          }\n          for (const value of discriminatorValues) {\n            if (optionsMap.has(value)) {\n              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n            }\n            optionsMap.set(value, type);\n          }\n        }\n        return new _ZodDiscriminatedUnion({\n          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n          discriminator,\n          options,\n          optionsMap,\n          ...processCreateParams(params)\n        });\n      }\n    };\n    __name(mergeValues, \"mergeValues\");\n    ZodIntersection = class extends ZodType {\n      static {\n        __name(this, \"ZodIntersection\");\n      }\n      _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = /* @__PURE__ */ __name((parsedLeft, parsedRight) => {\n          if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n            return INVALID;\n          }\n          const merged = mergeValues(parsedLeft.value, parsedRight.value);\n          if (!merged.valid) {\n            addIssueToContext(ctx, {\n              code: ZodIssueCode.invalid_intersection_types\n            });\n            return INVALID;\n          }\n          if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n            status.dirty();\n          }\n          return { status: status.value, value: merged.data };\n        }, \"handleParsed\");\n        if (ctx.common.async) {\n          return Promise.all([\n            this._def.left._parseAsync({\n              data: ctx.data,\n              path: ctx.path,\n              parent: ctx\n            }),\n            this._def.right._parseAsync({\n              data: ctx.data,\n              path: ctx.path,\n              parent: ctx\n            })\n          ]).then(([left, right]) => handleParsed(left, right));\n        } else {\n          return handleParsed(this._def.left._parseSync({\n            data: ctx.data,\n            path: ctx.path,\n            parent: ctx\n          }), this._def.right._parseSync({\n            data: ctx.data,\n            path: ctx.path,\n            parent: ctx\n          }));\n        }\n      }\n    };\n    ZodIntersection.create = (left, right, params) => {\n      return new ZodIntersection({\n        left,\n        right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params)\n      });\n    };\n    ZodTuple = class _ZodTuple extends ZodType {\n      static {\n        __name(this, \"ZodTuple\");\n      }\n      _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.array) {\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.array,\n            received: ctx.parsedType\n          });\n          return INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            minimum: this._def.items.length,\n            inclusive: true,\n            exact: false,\n            type: \"array\"\n          });\n          return INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            maximum: this._def.items.length,\n            inclusive: true,\n            exact: false,\n            type: \"array\"\n          });\n          status.dirty();\n        }\n        const items = [...ctx.data].map((item, itemIndex) => {\n          const schema = this._def.items[itemIndex] || this._def.rest;\n          if (!schema)\n            return null;\n          return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        }).filter((x) => !!x);\n        if (ctx.common.async) {\n          return Promise.all(items).then((results) => {\n            return ParseStatus.mergeArray(status, results);\n          });\n        } else {\n          return ParseStatus.mergeArray(status, items);\n        }\n      }\n      get items() {\n        return this._def.items;\n      }\n      rest(rest) {\n        return new _ZodTuple({\n          ...this._def,\n          rest\n        });\n      }\n    };\n    ZodTuple.create = (schemas, params) => {\n      if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n      }\n      return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params)\n      });\n    };\n    ZodRecord = class _ZodRecord extends ZodType {\n      static {\n        __name(this, \"ZodRecord\");\n      }\n      get keySchema() {\n        return this._def.keyType;\n      }\n      get valueSchema() {\n        return this._def.valueType;\n      }\n      _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.object,\n            received: ctx.parsedType\n          });\n          return INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for (const key in ctx.data) {\n          pairs.push({\n            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n            alwaysSet: key in ctx.data\n          });\n        }\n        if (ctx.common.async) {\n          return ParseStatus.mergeObjectAsync(status, pairs);\n        } else {\n          return ParseStatus.mergeObjectSync(status, pairs);\n        }\n      }\n      get element() {\n        return this._def.valueType;\n      }\n      static create(first, second, third) {\n        if (second instanceof ZodType) {\n          return new _ZodRecord({\n            keyType: first,\n            valueType: second,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(third)\n          });\n        }\n        return new _ZodRecord({\n          keyType: ZodString.create(),\n          valueType: first,\n          typeName: ZodFirstPartyTypeKind.ZodRecord,\n          ...processCreateParams(second)\n        });\n      }\n    };\n    ZodMap = class extends ZodType {\n      static {\n        __name(this, \"ZodMap\");\n      }\n      get keySchema() {\n        return this._def.keyType;\n      }\n      get valueSchema() {\n        return this._def.valueType;\n      }\n      _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.map) {\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.map,\n            received: ctx.parsedType\n          });\n          return INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n          return {\n            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"]))\n          };\n        });\n        if (ctx.common.async) {\n          const finalMap = /* @__PURE__ */ new Map();\n          return Promise.resolve().then(async () => {\n            for (const pair of pairs) {\n              const key = await pair.key;\n              const value = await pair.value;\n              if (key.status === \"aborted\" || value.status === \"aborted\") {\n                return INVALID;\n              }\n              if (key.status === \"dirty\" || value.status === \"dirty\") {\n                status.dirty();\n              }\n              finalMap.set(key.value, value.value);\n            }\n            return { status: status.value, value: finalMap };\n          });\n        } else {\n          const finalMap = /* @__PURE__ */ new Map();\n          for (const pair of pairs) {\n            const key = pair.key;\n            const value = pair.value;\n            if (key.status === \"aborted\" || value.status === \"aborted\") {\n              return INVALID;\n            }\n            if (key.status === \"dirty\" || value.status === \"dirty\") {\n              status.dirty();\n            }\n            finalMap.set(key.value, value.value);\n          }\n          return { status: status.value, value: finalMap };\n        }\n      }\n    };\n    ZodMap.create = (keyType, valueType, params) => {\n      return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params)\n      });\n    };\n    ZodSet = class _ZodSet extends ZodType {\n      static {\n        __name(this, \"ZodSet\");\n      }\n      _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.set) {\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.set,\n            received: ctx.parsedType\n          });\n          return INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n          if (ctx.data.size < def.minSize.value) {\n            addIssueToContext(ctx, {\n              code: ZodIssueCode.too_small,\n              minimum: def.minSize.value,\n              type: \"set\",\n              inclusive: true,\n              exact: false,\n              message: def.minSize.message\n            });\n            status.dirty();\n          }\n        }\n        if (def.maxSize !== null) {\n          if (ctx.data.size > def.maxSize.value) {\n            addIssueToContext(ctx, {\n              code: ZodIssueCode.too_big,\n              maximum: def.maxSize.value,\n              type: \"set\",\n              inclusive: true,\n              exact: false,\n              message: def.maxSize.message\n            });\n            status.dirty();\n          }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements2) {\n          const parsedSet = /* @__PURE__ */ new Set();\n          for (const element of elements2) {\n            if (element.status === \"aborted\")\n              return INVALID;\n            if (element.status === \"dirty\")\n              status.dirty();\n            parsedSet.add(element.value);\n          }\n          return { status: status.value, value: parsedSet };\n        }\n        __name(finalizeSet, \"finalizeSet\");\n        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n          return Promise.all(elements).then((elements2) => finalizeSet(elements2));\n        } else {\n          return finalizeSet(elements);\n        }\n      }\n      min(minSize, message) {\n        return new _ZodSet({\n          ...this._def,\n          minSize: { value: minSize, message: errorUtil.toString(message) }\n        });\n      }\n      max(maxSize, message) {\n        return new _ZodSet({\n          ...this._def,\n          maxSize: { value: maxSize, message: errorUtil.toString(message) }\n        });\n      }\n      size(size, message) {\n        return this.min(size, message).max(size, message);\n      }\n      nonempty(message) {\n        return this.min(1, message);\n      }\n    };\n    ZodSet.create = (valueType, params) => {\n      return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params)\n      });\n    };\n    ZodFunction = class _ZodFunction extends ZodType {\n      static {\n        __name(this, \"ZodFunction\");\n      }\n      constructor() {\n        super(...arguments);\n        this.validate = this.implement;\n      }\n      _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.function) {\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.function,\n            received: ctx.parsedType\n          });\n          return INVALID;\n        }\n        function makeArgsIssue(args, error) {\n          return makeIssue({\n            data: args,\n            path: ctx.path,\n            errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),\n            issueData: {\n              code: ZodIssueCode.invalid_arguments,\n              argumentsError: error\n            }\n          });\n        }\n        __name(makeArgsIssue, \"makeArgsIssue\");\n        function makeReturnsIssue(returns, error) {\n          return makeIssue({\n            data: returns,\n            path: ctx.path,\n            errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),\n            issueData: {\n              code: ZodIssueCode.invalid_return_type,\n              returnTypeError: error\n            }\n          });\n        }\n        __name(makeReturnsIssue, \"makeReturnsIssue\");\n        const params = { errorMap: ctx.common.contextualErrorMap };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n          const me = this;\n          return OK(async function(...args) {\n            const error = new ZodError([]);\n            const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {\n              error.addIssue(makeArgsIssue(args, e));\n              throw error;\n            });\n            const result = await Reflect.apply(fn, this, parsedArgs);\n            const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {\n              error.addIssue(makeReturnsIssue(result, e));\n              throw error;\n            });\n            return parsedReturns;\n          });\n        } else {\n          const me = this;\n          return OK(function(...args) {\n            const parsedArgs = me._def.args.safeParse(args, params);\n            if (!parsedArgs.success) {\n              throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n            }\n            const result = Reflect.apply(fn, this, parsedArgs.data);\n            const parsedReturns = me._def.returns.safeParse(result, params);\n            if (!parsedReturns.success) {\n              throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n            }\n            return parsedReturns.data;\n          });\n        }\n      }\n      parameters() {\n        return this._def.args;\n      }\n      returnType() {\n        return this._def.returns;\n      }\n      args(...items) {\n        return new _ZodFunction({\n          ...this._def,\n          args: ZodTuple.create(items).rest(ZodUnknown.create())\n        });\n      }\n      returns(returnType) {\n        return new _ZodFunction({\n          ...this._def,\n          returns: returnType\n        });\n      }\n      implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n      }\n      strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n      }\n      static create(args, returns, params) {\n        return new _ZodFunction({\n          args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),\n          returns: returns || ZodUnknown.create(),\n          typeName: ZodFirstPartyTypeKind.ZodFunction,\n          ...processCreateParams(params)\n        });\n      }\n    };\n    ZodLazy = class extends ZodType {\n      static {\n        __name(this, \"ZodLazy\");\n      }\n      get schema() {\n        return this._def.getter();\n      }\n      _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n      }\n    };\n    ZodLazy.create = (getter, params) => {\n      return new ZodLazy({\n        getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params)\n      });\n    };\n    ZodLiteral = class extends ZodType {\n      static {\n        __name(this, \"ZodLiteral\");\n      }\n      _parse(input) {\n        if (input.data !== this._def.value) {\n          const ctx = this._getOrReturnCtx(input);\n          addIssueToContext(ctx, {\n            received: ctx.data,\n            code: ZodIssueCode.invalid_literal,\n            expected: this._def.value\n          });\n          return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n      }\n      get value() {\n        return this._def.value;\n      }\n    };\n    ZodLiteral.create = (value, params) => {\n      return new ZodLiteral({\n        value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params)\n      });\n    };\n    __name(createZodEnum, \"createZodEnum\");\n    ZodEnum = class _ZodEnum extends ZodType {\n      static {\n        __name(this, \"ZodEnum\");\n      }\n      _parse(input) {\n        if (typeof input.data !== \"string\") {\n          const ctx = this._getOrReturnCtx(input);\n          const expectedValues = this._def.values;\n          addIssueToContext(ctx, {\n            expected: util.joinValues(expectedValues),\n            received: ctx.parsedType,\n            code: ZodIssueCode.invalid_type\n          });\n          return INVALID;\n        }\n        if (!this._cache) {\n          this._cache = new Set(this._def.values);\n        }\n        if (!this._cache.has(input.data)) {\n          const ctx = this._getOrReturnCtx(input);\n          const expectedValues = this._def.values;\n          addIssueToContext(ctx, {\n            received: ctx.data,\n            code: ZodIssueCode.invalid_enum_value,\n            options: expectedValues\n          });\n          return INVALID;\n        }\n        return OK(input.data);\n      }\n      get options() {\n        return this._def.values;\n      }\n      get enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n          enumValues[val] = val;\n        }\n        return enumValues;\n      }\n      get Values() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n          enumValues[val] = val;\n        }\n        return enumValues;\n      }\n      get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n          enumValues[val] = val;\n        }\n        return enumValues;\n      }\n      extract(values, newDef = this._def) {\n        return _ZodEnum.create(values, {\n          ...this._def,\n          ...newDef\n        });\n      }\n      exclude(values, newDef = this._def) {\n        return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {\n          ...this._def,\n          ...newDef\n        });\n      }\n    };\n    ZodEnum.create = createZodEnum;\n    ZodNativeEnum = class extends ZodType {\n      static {\n        __name(this, \"ZodNativeEnum\");\n      }\n      _parse(input) {\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n          const expectedValues = util.objectValues(nativeEnumValues);\n          addIssueToContext(ctx, {\n            expected: util.joinValues(expectedValues),\n            received: ctx.parsedType,\n            code: ZodIssueCode.invalid_type\n          });\n          return INVALID;\n        }\n        if (!this._cache) {\n          this._cache = new Set(util.getValidEnumValues(this._def.values));\n        }\n        if (!this._cache.has(input.data)) {\n          const expectedValues = util.objectValues(nativeEnumValues);\n          addIssueToContext(ctx, {\n            received: ctx.data,\n            code: ZodIssueCode.invalid_enum_value,\n            options: expectedValues\n          });\n          return INVALID;\n        }\n        return OK(input.data);\n      }\n      get enum() {\n        return this._def.values;\n      }\n    };\n    ZodNativeEnum.create = (values, params) => {\n      return new ZodNativeEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params)\n      });\n    };\n    ZodPromise = class extends ZodType {\n      static {\n        __name(this, \"ZodPromise\");\n      }\n      unwrap() {\n        return this._def.type;\n      }\n      _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.promise,\n            received: ctx.parsedType\n          });\n          return INVALID;\n        }\n        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n        return OK(promisified.then((data) => {\n          return this._def.type.parseAsync(data, {\n            path: ctx.path,\n            errorMap: ctx.common.contextualErrorMap\n          });\n        }));\n      }\n    };\n    ZodPromise.create = (schema, params) => {\n      return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params)\n      });\n    };\n    ZodEffects = class extends ZodType {\n      static {\n        __name(this, \"ZodEffects\");\n      }\n      innerType() {\n        return this._def.schema;\n      }\n      sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;\n      }\n      _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        const checkCtx = {\n          addIssue: /* @__PURE__ */ __name((arg) => {\n            addIssueToContext(ctx, arg);\n            if (arg.fatal) {\n              status.abort();\n            } else {\n              status.dirty();\n            }\n          }, \"addIssue\"),\n          get path() {\n            return ctx.path;\n          }\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"preprocess\") {\n          const processed = effect.transform(ctx.data, checkCtx);\n          if (ctx.common.async) {\n            return Promise.resolve(processed).then(async (processed2) => {\n              if (status.value === \"aborted\")\n                return INVALID;\n              const result = await this._def.schema._parseAsync({\n                data: processed2,\n                path: ctx.path,\n                parent: ctx\n              });\n              if (result.status === \"aborted\")\n                return INVALID;\n              if (result.status === \"dirty\")\n                return DIRTY(result.value);\n              if (status.value === \"dirty\")\n                return DIRTY(result.value);\n              return result;\n            });\n          } else {\n            if (status.value === \"aborted\")\n              return INVALID;\n            const result = this._def.schema._parseSync({\n              data: processed,\n              path: ctx.path,\n              parent: ctx\n            });\n            if (result.status === \"aborted\")\n              return INVALID;\n            if (result.status === \"dirty\")\n              return DIRTY(result.value);\n            if (status.value === \"dirty\")\n              return DIRTY(result.value);\n            return result;\n          }\n        }\n        if (effect.type === \"refinement\") {\n          const executeRefinement = /* @__PURE__ */ __name((acc) => {\n            const result = effect.refinement(acc, checkCtx);\n            if (ctx.common.async) {\n              return Promise.resolve(result);\n            }\n            if (result instanceof Promise) {\n              throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n            }\n            return acc;\n          }, \"executeRefinement\");\n          if (ctx.common.async === false) {\n            const inner = this._def.schema._parseSync({\n              data: ctx.data,\n              path: ctx.path,\n              parent: ctx\n            });\n            if (inner.status === \"aborted\")\n              return INVALID;\n            if (inner.status === \"dirty\")\n              status.dirty();\n            executeRefinement(inner.value);\n            return { status: status.value, value: inner.value };\n          } else {\n            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {\n              if (inner.status === \"aborted\")\n                return INVALID;\n              if (inner.status === \"dirty\")\n                status.dirty();\n              return executeRefinement(inner.value).then(() => {\n                return { status: status.value, value: inner.value };\n              });\n            });\n          }\n        }\n        if (effect.type === \"transform\") {\n          if (ctx.common.async === false) {\n            const base = this._def.schema._parseSync({\n              data: ctx.data,\n              path: ctx.path,\n              parent: ctx\n            });\n            if (!isValid(base))\n              return INVALID;\n            const result = effect.transform(base.value, checkCtx);\n            if (result instanceof Promise) {\n              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n            }\n            return { status: status.value, value: result };\n          } else {\n            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {\n              if (!isValid(base))\n                return INVALID;\n              return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({\n                status: status.value,\n                value: result\n              }));\n            });\n          }\n        }\n        util.assertNever(effect);\n      }\n    };\n    ZodEffects.create = (schema, effect, params) => {\n      return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params)\n      });\n    };\n    ZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n      return new ZodEffects({\n        schema,\n        effect: { type: \"preprocess\", transform: preprocess },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params)\n      });\n    };\n    ZodOptional = class extends ZodType {\n      static {\n        __name(this, \"ZodOptional\");\n      }\n      _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.undefined) {\n          return OK(void 0);\n        }\n        return this._def.innerType._parse(input);\n      }\n      unwrap() {\n        return this._def.innerType;\n      }\n    };\n    ZodOptional.create = (type, params) => {\n      return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params)\n      });\n    };\n    ZodNullable = class extends ZodType {\n      static {\n        __name(this, \"ZodNullable\");\n      }\n      _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.null) {\n          return OK(null);\n        }\n        return this._def.innerType._parse(input);\n      }\n      unwrap() {\n        return this._def.innerType;\n      }\n    };\n    ZodNullable.create = (type, params) => {\n      return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params)\n      });\n    };\n    ZodDefault = class extends ZodType {\n      static {\n        __name(this, \"ZodDefault\");\n      }\n      _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === ZodParsedType.undefined) {\n          data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n          data,\n          path: ctx.path,\n          parent: ctx\n        });\n      }\n      removeDefault() {\n        return this._def.innerType;\n      }\n    };\n    ZodDefault.create = (type, params) => {\n      return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\" ? params.default : () => params.default,\n        ...processCreateParams(params)\n      });\n    };\n    ZodCatch = class extends ZodType {\n      static {\n        __name(this, \"ZodCatch\");\n      }\n      _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const newCtx = {\n          ...ctx,\n          common: {\n            ...ctx.common,\n            issues: []\n          }\n        };\n        const result = this._def.innerType._parse({\n          data: newCtx.data,\n          path: newCtx.path,\n          parent: {\n            ...newCtx\n          }\n        });\n        if (isAsync(result)) {\n          return result.then((result2) => {\n            return {\n              status: \"valid\",\n              value: result2.status === \"valid\" ? result2.value : this._def.catchValue({\n                get error() {\n                  return new ZodError(newCtx.common.issues);\n                },\n                input: newCtx.data\n              })\n            };\n          });\n        } else {\n          return {\n            status: \"valid\",\n            value: result.status === \"valid\" ? result.value : this._def.catchValue({\n              get error() {\n                return new ZodError(newCtx.common.issues);\n              },\n              input: newCtx.data\n            })\n          };\n        }\n      }\n      removeCatch() {\n        return this._def.innerType;\n      }\n    };\n    ZodCatch.create = (type, params) => {\n      return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n        ...processCreateParams(params)\n      });\n    };\n    ZodNaN = class extends ZodType {\n      static {\n        __name(this, \"ZodNaN\");\n      }\n      _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.nan) {\n          const ctx = this._getOrReturnCtx(input);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.nan,\n            received: ctx.parsedType\n          });\n          return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n      }\n    };\n    ZodNaN.create = (params) => {\n      return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params)\n      });\n    };\n    BRAND = Symbol(\"zod_brand\");\n    ZodBranded = class extends ZodType {\n      static {\n        __name(this, \"ZodBranded\");\n      }\n      _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n          data,\n          path: ctx.path,\n          parent: ctx\n        });\n      }\n      unwrap() {\n        return this._def.type;\n      }\n    };\n    ZodPipeline = class _ZodPipeline extends ZodType {\n      static {\n        __name(this, \"ZodPipeline\");\n      }\n      _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n          const handleAsync = /* @__PURE__ */ __name(async () => {\n            const inResult = await this._def.in._parseAsync({\n              data: ctx.data,\n              path: ctx.path,\n              parent: ctx\n            });\n            if (inResult.status === \"aborted\")\n              return INVALID;\n            if (inResult.status === \"dirty\") {\n              status.dirty();\n              return DIRTY(inResult.value);\n            } else {\n              return this._def.out._parseAsync({\n                data: inResult.value,\n                path: ctx.path,\n                parent: ctx\n              });\n            }\n          }, \"handleAsync\");\n          return handleAsync();\n        } else {\n          const inResult = this._def.in._parseSync({\n            data: ctx.data,\n            path: ctx.path,\n            parent: ctx\n          });\n          if (inResult.status === \"aborted\")\n            return INVALID;\n          if (inResult.status === \"dirty\") {\n            status.dirty();\n            return {\n              status: \"dirty\",\n              value: inResult.value\n            };\n          } else {\n            return this._def.out._parseSync({\n              data: inResult.value,\n              path: ctx.path,\n              parent: ctx\n            });\n          }\n        }\n      }\n      static create(a, b) {\n        return new _ZodPipeline({\n          in: a,\n          out: b,\n          typeName: ZodFirstPartyTypeKind.ZodPipeline\n        });\n      }\n    };\n    ZodReadonly = class extends ZodType {\n      static {\n        __name(this, \"ZodReadonly\");\n      }\n      _parse(input) {\n        const result = this._def.innerType._parse(input);\n        const freeze = /* @__PURE__ */ __name((data) => {\n          if (isValid(data)) {\n            data.value = Object.freeze(data.value);\n          }\n          return data;\n        }, \"freeze\");\n        return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);\n      }\n      unwrap() {\n        return this._def.innerType;\n      }\n    };\n    ZodReadonly.create = (type, params) => {\n      return new ZodReadonly({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\n        ...processCreateParams(params)\n      });\n    };\n    __name(cleanParams, \"cleanParams\");\n    __name(custom, \"custom\");\n    late = {\n      object: ZodObject.lazycreate\n    };\n    (function(ZodFirstPartyTypeKind2) {\n      ZodFirstPartyTypeKind2[\"ZodString\"] = \"ZodString\";\n      ZodFirstPartyTypeKind2[\"ZodNumber\"] = \"ZodNumber\";\n      ZodFirstPartyTypeKind2[\"ZodNaN\"] = \"ZodNaN\";\n      ZodFirstPartyTypeKind2[\"ZodBigInt\"] = \"ZodBigInt\";\n      ZodFirstPartyTypeKind2[\"ZodBoolean\"] = \"ZodBoolean\";\n      ZodFirstPartyTypeKind2[\"ZodDate\"] = \"ZodDate\";\n      ZodFirstPartyTypeKind2[\"ZodSymbol\"] = \"ZodSymbol\";\n      ZodFirstPartyTypeKind2[\"ZodUndefined\"] = \"ZodUndefined\";\n      ZodFirstPartyTypeKind2[\"ZodNull\"] = \"ZodNull\";\n      ZodFirstPartyTypeKind2[\"ZodAny\"] = \"ZodAny\";\n      ZodFirstPartyTypeKind2[\"ZodUnknown\"] = \"ZodUnknown\";\n      ZodFirstPartyTypeKind2[\"ZodNever\"] = \"ZodNever\";\n      ZodFirstPartyTypeKind2[\"ZodVoid\"] = \"ZodVoid\";\n      ZodFirstPartyTypeKind2[\"ZodArray\"] = \"ZodArray\";\n      ZodFirstPartyTypeKind2[\"ZodObject\"] = \"ZodObject\";\n      ZodFirstPartyTypeKind2[\"ZodUnion\"] = \"ZodUnion\";\n      ZodFirstPartyTypeKind2[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n      ZodFirstPartyTypeKind2[\"ZodIntersection\"] = \"ZodIntersection\";\n      ZodFirstPartyTypeKind2[\"ZodTuple\"] = \"ZodTuple\";\n      ZodFirstPartyTypeKind2[\"ZodRecord\"] = \"ZodRecord\";\n      ZodFirstPartyTypeKind2[\"ZodMap\"] = \"ZodMap\";\n      ZodFirstPartyTypeKind2[\"ZodSet\"] = \"ZodSet\";\n      ZodFirstPartyTypeKind2[\"ZodFunction\"] = \"ZodFunction\";\n      ZodFirstPartyTypeKind2[\"ZodLazy\"] = \"ZodLazy\";\n      ZodFirstPartyTypeKind2[\"ZodLiteral\"] = \"ZodLiteral\";\n      ZodFirstPartyTypeKind2[\"ZodEnum\"] = \"ZodEnum\";\n      ZodFirstPartyTypeKind2[\"ZodEffects\"] = \"ZodEffects\";\n      ZodFirstPartyTypeKind2[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n      ZodFirstPartyTypeKind2[\"ZodOptional\"] = \"ZodOptional\";\n      ZodFirstPartyTypeKind2[\"ZodNullable\"] = \"ZodNullable\";\n      ZodFirstPartyTypeKind2[\"ZodDefault\"] = \"ZodDefault\";\n      ZodFirstPartyTypeKind2[\"ZodCatch\"] = \"ZodCatch\";\n      ZodFirstPartyTypeKind2[\"ZodPromise\"] = \"ZodPromise\";\n      ZodFirstPartyTypeKind2[\"ZodBranded\"] = \"ZodBranded\";\n      ZodFirstPartyTypeKind2[\"ZodPipeline\"] = \"ZodPipeline\";\n      ZodFirstPartyTypeKind2[\"ZodReadonly\"] = \"ZodReadonly\";\n    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\n    instanceOfType = /* @__PURE__ */ __name((cls, params = {\n      message: `Input not instance of ${cls.name}`\n    }) => custom((data) => data instanceof cls, params), \"instanceOfType\");\n    stringType = ZodString.create;\n    numberType = ZodNumber.create;\n    nanType = ZodNaN.create;\n    bigIntType = ZodBigInt.create;\n    booleanType = ZodBoolean.create;\n    dateType = ZodDate.create;\n    symbolType = ZodSymbol.create;\n    undefinedType = ZodUndefined.create;\n    nullType = ZodNull.create;\n    anyType = ZodAny.create;\n    unknownType = ZodUnknown.create;\n    neverType = ZodNever.create;\n    voidType = ZodVoid.create;\n    arrayType = ZodArray.create;\n    objectType = ZodObject.create;\n    strictObjectType = ZodObject.strictCreate;\n    unionType = ZodUnion.create;\n    discriminatedUnionType = ZodDiscriminatedUnion.create;\n    intersectionType = ZodIntersection.create;\n    tupleType = ZodTuple.create;\n    recordType = ZodRecord.create;\n    mapType = ZodMap.create;\n    setType = ZodSet.create;\n    functionType = ZodFunction.create;\n    lazyType = ZodLazy.create;\n    literalType = ZodLiteral.create;\n    enumType = ZodEnum.create;\n    nativeEnumType = ZodNativeEnum.create;\n    promiseType = ZodPromise.create;\n    effectsType = ZodEffects.create;\n    optionalType = ZodOptional.create;\n    nullableType = ZodNullable.create;\n    preprocessType = ZodEffects.createWithPreprocess;\n    pipelineType = ZodPipeline.create;\n    ostring = /* @__PURE__ */ __name(() => stringType().optional(), \"ostring\");\n    onumber = /* @__PURE__ */ __name(() => numberType().optional(), \"onumber\");\n    oboolean = /* @__PURE__ */ __name(() => booleanType().optional(), \"oboolean\");\n    coerce = {\n      string: /* @__PURE__ */ __name((arg) => ZodString.create({ ...arg, coerce: true }), \"string\"),\n      number: /* @__PURE__ */ __name((arg) => ZodNumber.create({ ...arg, coerce: true }), \"number\"),\n      boolean: /* @__PURE__ */ __name((arg) => ZodBoolean.create({\n        ...arg,\n        coerce: true\n      }), \"boolean\"),\n      bigint: /* @__PURE__ */ __name((arg) => ZodBigInt.create({ ...arg, coerce: true }), \"bigint\"),\n      date: /* @__PURE__ */ __name((arg) => ZodDate.create({ ...arg, coerce: true }), \"date\")\n    };\n    NEVER = INVALID;\n  }\n});\n\n// node_modules/zod/dist/esm/v3/external.js\nvar external_exports = {};\n__export(external_exports, {\n  BRAND: () => BRAND,\n  DIRTY: () => DIRTY,\n  EMPTY_PATH: () => EMPTY_PATH,\n  INVALID: () => INVALID,\n  NEVER: () => NEVER,\n  OK: () => OK,\n  ParseStatus: () => ParseStatus,\n  Schema: () => ZodType,\n  ZodAny: () => ZodAny,\n  ZodArray: () => ZodArray,\n  ZodBigInt: () => ZodBigInt,\n  ZodBoolean: () => ZodBoolean,\n  ZodBranded: () => ZodBranded,\n  ZodCatch: () => ZodCatch,\n  ZodDate: () => ZodDate,\n  ZodDefault: () => ZodDefault,\n  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,\n  ZodEffects: () => ZodEffects,\n  ZodEnum: () => ZodEnum,\n  ZodError: () => ZodError,\n  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,\n  ZodFunction: () => ZodFunction,\n  ZodIntersection: () => ZodIntersection,\n  ZodIssueCode: () => ZodIssueCode,\n  ZodLazy: () => ZodLazy,\n  ZodLiteral: () => ZodLiteral,\n  ZodMap: () => ZodMap,\n  ZodNaN: () => ZodNaN,\n  ZodNativeEnum: () => ZodNativeEnum,\n  ZodNever: () => ZodNever,\n  ZodNull: () => ZodNull,\n  ZodNullable: () => ZodNullable,\n  ZodNumber: () => ZodNumber,\n  ZodObject: () => ZodObject,\n  ZodOptional: () => ZodOptional,\n  ZodParsedType: () => ZodParsedType,\n  ZodPipeline: () => ZodPipeline,\n  ZodPromise: () => ZodPromise,\n  ZodReadonly: () => ZodReadonly,\n  ZodRecord: () => ZodRecord,\n  ZodSchema: () => ZodType,\n  ZodSet: () => ZodSet,\n  ZodString: () => ZodString,\n  ZodSymbol: () => ZodSymbol,\n  ZodTransformer: () => ZodEffects,\n  ZodTuple: () => ZodTuple,\n  ZodType: () => ZodType,\n  ZodUndefined: () => ZodUndefined,\n  ZodUnion: () => ZodUnion,\n  ZodUnknown: () => ZodUnknown,\n  ZodVoid: () => ZodVoid,\n  addIssueToContext: () => addIssueToContext,\n  any: () => anyType,\n  array: () => arrayType,\n  bigint: () => bigIntType,\n  boolean: () => booleanType,\n  coerce: () => coerce,\n  custom: () => custom,\n  date: () => dateType,\n  datetimeRegex: () => datetimeRegex,\n  defaultErrorMap: () => en_default,\n  discriminatedUnion: () => discriminatedUnionType,\n  effect: () => effectsType,\n  enum: () => enumType,\n  function: () => functionType,\n  getErrorMap: () => getErrorMap,\n  getParsedType: () => getParsedType,\n  instanceof: () => instanceOfType,\n  intersection: () => intersectionType,\n  isAborted: () => isAborted,\n  isAsync: () => isAsync,\n  isDirty: () => isDirty,\n  isValid: () => isValid,\n  late: () => late,\n  lazy: () => lazyType,\n  literal: () => literalType,\n  makeIssue: () => makeIssue,\n  map: () => mapType,\n  nan: () => nanType,\n  nativeEnum: () => nativeEnumType,\n  never: () => neverType,\n  null: () => nullType,\n  nullable: () => nullableType,\n  number: () => numberType,\n  object: () => objectType,\n  objectUtil: () => objectUtil,\n  oboolean: () => oboolean,\n  onumber: () => onumber,\n  optional: () => optionalType,\n  ostring: () => ostring,\n  pipeline: () => pipelineType,\n  preprocess: () => preprocessType,\n  promise: () => promiseType,\n  quotelessJson: () => quotelessJson,\n  record: () => recordType,\n  set: () => setType,\n  setErrorMap: () => setErrorMap,\n  strictObject: () => strictObjectType,\n  string: () => stringType,\n  symbol: () => symbolType,\n  transformer: () => effectsType,\n  tuple: () => tupleType,\n  undefined: () => undefinedType,\n  union: () => unionType,\n  unknown: () => unknownType,\n  util: () => util,\n  void: () => voidType\n});\nvar init_external = __esm({\n  \"node_modules/zod/dist/esm/v3/external.js\"() {\n    init_errors();\n    init_parseUtil();\n    init_typeAliases();\n    init_util();\n    init_types();\n    init_ZodError();\n  }\n});\n\n// node_modules/zod/dist/esm/v3/index.js\nvar init_v3 = __esm({\n  \"node_modules/zod/dist/esm/v3/index.js\"() {\n    init_external();\n    init_external();\n  }\n});\n\n// node_modules/zod/dist/esm/index.js\nvar init_esm = __esm({\n  \"node_modules/zod/dist/esm/index.js\"() {\n    init_v3();\n    init_v3();\n  }\n});\n\n// node_modules/@tsndr/cloudflare-worker-jwt/index.js\nfunction bytesToByteString(bytes) {\n  let byteStr = \"\";\n  for (let i = 0; i < bytes.byteLength; i++) {\n    byteStr += String.fromCharCode(bytes[i]);\n  }\n  return byteStr;\n}\nfunction byteStringToBytes(byteStr) {\n  let bytes = new Uint8Array(byteStr.length);\n  for (let i = 0; i < byteStr.length; i++) {\n    bytes[i] = byteStr.charCodeAt(i);\n  }\n  return bytes;\n}\nfunction arrayBufferToBase64String(arrayBuffer) {\n  return btoa(bytesToByteString(new Uint8Array(arrayBuffer)));\n}\nfunction base64StringToUint8Array(b64str) {\n  return byteStringToBytes(atob(b64str));\n}\nfunction textToUint8Array(str) {\n  return byteStringToBytes(str);\n}\nfunction arrayBufferToBase64Url(arrayBuffer) {\n  return arrayBufferToBase64String(arrayBuffer).replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\nfunction base64UrlToUint8Array(b64url) {\n  return base64StringToUint8Array(b64url.replace(/-/g, \"+\").replace(/_/g, \"/\").replace(/\\s/g, \"\"));\n}\nfunction textToBase64Url(str) {\n  const encoder = new TextEncoder();\n  const charCodes = encoder.encode(str);\n  const binaryStr = String.fromCharCode(...charCodes);\n  return btoa(binaryStr).replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\nfunction pemToBinary(pem) {\n  return base64StringToUint8Array(pem.replace(/-+(BEGIN|END).*/g, \"\").replace(/\\s/g, \"\"));\n}\nasync function importTextSecret(key, algorithm, keyUsages) {\n  return await crypto.subtle.importKey(\"raw\", textToUint8Array(key), algorithm, true, keyUsages);\n}\nasync function importJwk(key, algorithm, keyUsages) {\n  return await crypto.subtle.importKey(\"jwk\", key, algorithm, true, keyUsages);\n}\nasync function importPublicKey(key, algorithm, keyUsages) {\n  return await crypto.subtle.importKey(\"spki\", pemToBinary(key), algorithm, true, keyUsages);\n}\nasync function importPrivateKey(key, algorithm, keyUsages) {\n  return await crypto.subtle.importKey(\"pkcs8\", pemToBinary(key), algorithm, true, keyUsages);\n}\nasync function importKey(key, algorithm, keyUsages) {\n  if (typeof key === \"object\")\n    return importJwk(key, algorithm, keyUsages);\n  if (typeof key !== \"string\")\n    throw new Error(\"Unsupported key type!\");\n  if (key.includes(\"PUBLIC\"))\n    return importPublicKey(key, algorithm, keyUsages);\n  if (key.includes(\"PRIVATE\"))\n    return importPrivateKey(key, algorithm, keyUsages);\n  return importTextSecret(key, algorithm, keyUsages);\n}\nfunction decodePayload(raw) {\n  const bytes = Array.from(atob(raw), (char) => char.charCodeAt(0));\n  const decodedString = new TextDecoder(\"utf-8\").decode(new Uint8Array(bytes));\n  return JSON.parse(decodedString);\n}\nasync function sign(payload, secret, options = \"HS256\") {\n  if (typeof options === \"string\")\n    options = { algorithm: options };\n  options = { algorithm: \"HS256\", header: { typ: \"JWT\", ...options.header ?? {} }, ...options };\n  if (!payload || typeof payload !== \"object\")\n    throw new Error(\"payload must be an object\");\n  if (options.algorithm !== \"none\" && (!secret || typeof secret !== \"string\" && typeof secret !== \"object\"))\n    throw new Error(\"secret must be a string, a JWK object or a CryptoKey object\");\n  if (typeof options.algorithm !== \"string\")\n    throw new Error(\"options.algorithm must be a string\");\n  const algorithm = algorithms[options.algorithm];\n  if (!algorithm)\n    throw new Error(\"algorithm not found\");\n  if (!payload.iat)\n    payload.iat = Math.floor(Date.now() / 1e3);\n  const partialToken = `${textToBase64Url(JSON.stringify({ ...options.header, alg: options.algorithm }))}.${textToBase64Url(JSON.stringify(payload))}`;\n  if (options.algorithm === \"none\")\n    return partialToken;\n  const key = secret instanceof CryptoKey ? secret : await importKey(secret, algorithm, [\"sign\"]);\n  const signature = await crypto.subtle.sign(algorithm, key, textToUint8Array(partialToken));\n  return `${partialToken}.${arrayBufferToBase64Url(signature)}`;\n}\nasync function verify(token, secret, options = \"HS256\") {\n  if (typeof options === \"string\")\n    options = { algorithm: options };\n  options = { algorithm: \"HS256\", clockTolerance: 0, throwError: false, ...options };\n  if (typeof token !== \"string\")\n    throw new Error(\"token must be a string\");\n  if (options.algorithm !== \"none\" && typeof secret !== \"string\" && typeof secret !== \"object\")\n    throw new Error(\"secret must be a string, a JWK object or a CryptoKey object\");\n  if (typeof options.algorithm !== \"string\")\n    throw new Error(\"options.algorithm must be a string\");\n  const tokenParts = token.split(\".\", 3);\n  if (tokenParts.length < 2)\n    throw new Error(\"token must consist of 2 or more parts\");\n  const [tokenHeader, tokenPayload, tokenSignature] = tokenParts;\n  const algorithm = algorithms[options.algorithm];\n  if (!algorithm)\n    throw new Error(\"algorithm not found\");\n  const decodedToken = decode(token);\n  try {\n    if (decodedToken.header?.alg !== options.algorithm)\n      throw new Error(\"INVALID_SIGNATURE\");\n    if (decodedToken.payload) {\n      const now = Math.floor(Date.now() / 1e3);\n      if (decodedToken.payload.nbf && decodedToken.payload.nbf > now && decodedToken.payload.nbf - now > (options.clockTolerance ?? 0))\n        throw new Error(\"NOT_YET_VALID\");\n      if (decodedToken.payload.exp && decodedToken.payload.exp <= now && now - decodedToken.payload.exp > (options.clockTolerance ?? 0))\n        throw new Error(\"EXPIRED\");\n    }\n    if (algorithm.name === \"none\")\n      return decodedToken;\n    const key = secret instanceof CryptoKey ? secret : await importKey(secret, algorithm, [\"verify\"]);\n    if (!await crypto.subtle.verify(algorithm, key, base64UrlToUint8Array(tokenSignature), textToUint8Array(`${tokenHeader}.${tokenPayload}`)))\n      throw new Error(\"INVALID_SIGNATURE\");\n    return decodedToken;\n  } catch (err) {\n    if (options.throwError)\n      throw err;\n    return;\n  }\n}\nfunction decode(token) {\n  return {\n    header: decodePayload(token.split(\".\")[0].replace(/-/g, \"+\").replace(/_/g, \"/\")),\n    payload: decodePayload(token.split(\".\")[1].replace(/-/g, \"+\").replace(/_/g, \"/\"))\n  };\n}\nvar algorithms, index_default;\nvar init_cloudflare_worker_jwt = __esm({\n  \"node_modules/@tsndr/cloudflare-worker-jwt/index.js\"() {\n    __name(bytesToByteString, \"bytesToByteString\");\n    __name(byteStringToBytes, \"byteStringToBytes\");\n    __name(arrayBufferToBase64String, \"arrayBufferToBase64String\");\n    __name(base64StringToUint8Array, \"base64StringToUint8Array\");\n    __name(textToUint8Array, \"textToUint8Array\");\n    __name(arrayBufferToBase64Url, \"arrayBufferToBase64Url\");\n    __name(base64UrlToUint8Array, \"base64UrlToUint8Array\");\n    __name(textToBase64Url, \"textToBase64Url\");\n    __name(pemToBinary, \"pemToBinary\");\n    __name(importTextSecret, \"importTextSecret\");\n    __name(importJwk, \"importJwk\");\n    __name(importPublicKey, \"importPublicKey\");\n    __name(importPrivateKey, \"importPrivateKey\");\n    __name(importKey, \"importKey\");\n    __name(decodePayload, \"decodePayload\");\n    if (typeof crypto === \"undefined\" || !crypto.subtle)\n      throw new Error(\"SubtleCrypto not supported!\");\n    algorithms = {\n      none: { name: \"none\" },\n      ES256: { name: \"ECDSA\", namedCurve: \"P-256\", hash: { name: \"SHA-256\" } },\n      ES384: { name: \"ECDSA\", namedCurve: \"P-384\", hash: { name: \"SHA-384\" } },\n      ES512: { name: \"ECDSA\", namedCurve: \"P-521\", hash: { name: \"SHA-512\" } },\n      HS256: { name: \"HMAC\", hash: { name: \"SHA-256\" } },\n      HS384: { name: \"HMAC\", hash: { name: \"SHA-384\" } },\n      HS512: { name: \"HMAC\", hash: { name: \"SHA-512\" } },\n      RS256: { name: \"RSASSA-PKCS1-v1_5\", hash: { name: \"SHA-256\" } },\n      RS384: { name: \"RSASSA-PKCS1-v1_5\", hash: { name: \"SHA-384\" } },\n      RS512: { name: \"RSASSA-PKCS1-v1_5\", hash: { name: \"SHA-512\" } }\n    };\n    __name(sign, \"sign\");\n    __name(verify, \"verify\");\n    __name(decode, \"decode\");\n    index_default = {\n      sign,\n      verify,\n      decode\n    };\n  }\n});\n\n// node_modules/userdo/dist/src/database/query.js\nvar GenericQuery;\nvar init_query = __esm({\n  \"node_modules/userdo/dist/src/database/query.js\"() {\n    GenericQuery = class {\n      static {\n        __name(this, \"GenericQuery\");\n      }\n      constructor(tableName, storage, schema, userId) {\n        this.tableName = tableName;\n        this.storage = storage;\n        this.schema = schema;\n        this.userId = userId;\n        this.conditions = [];\n      }\n      where(path, operator, value) {\n        this.conditions.push({ path, operator, value });\n        return this;\n      }\n      orderBy(field, direction = \"asc\") {\n        this.orderByClause = { field, direction };\n        return this;\n      }\n      limit(count) {\n        this.limitCount = count;\n        return this;\n      }\n      offset(count) {\n        this.offsetCount = count;\n        return this;\n      }\n      async get() {\n        let sql = `SELECT * FROM \"${this.tableName}\" WHERE user_id = ?`;\n        const params = [this.userId];\n        if (this.conditions.length > 0) {\n          const whereConditions = this.conditions.map((c) => {\n            const jsonPath = `$.${c.path}`;\n            switch (c.operator) {\n              case \"==\":\n                params.push(c.value);\n                return `json_extract(data, '${jsonPath}') = ?`;\n              case \"!=\":\n                params.push(c.value);\n                return `json_extract(data, '${jsonPath}') != ?`;\n              case \">\":\n                params.push(c.value);\n                return `json_extract(data, '${jsonPath}') > ?`;\n              case \"<\":\n                params.push(c.value);\n                return `json_extract(data, '${jsonPath}') < ?`;\n              case \"includes\":\n                params.push(`%${c.value}%`);\n                return `json_extract(data, '${jsonPath}') LIKE ?`;\n              default:\n                throw new Error(`Unsupported operator: ${c.operator}`);\n            }\n          });\n          sql += ` AND (${whereConditions.join(\" AND \")})`;\n        }\n        if (this.orderByClause) {\n          const { field, direction } = this.orderByClause;\n          if (field === \"createdAt\" || field === \"updatedAt\") {\n            const dbField = field === \"createdAt\" ? \"created_at\" : \"updated_at\";\n            sql += ` ORDER BY ${dbField} ${direction.toUpperCase()}`;\n          } else {\n            const jsonPath = `$.${field}`;\n            sql += ` ORDER BY json_extract(data, '${jsonPath}') ${direction.toUpperCase()}`;\n          }\n        }\n        if (this.limitCount) {\n          sql += ` LIMIT ${this.limitCount}`;\n        }\n        if (this.offsetCount) {\n          sql += ` OFFSET ${this.offsetCount}`;\n        }\n        const cursor = this.storage.sql.exec(sql, ...params);\n        const results = [];\n        for (const row of cursor) {\n          const data = JSON.parse(row.data);\n          results.push({\n            ...data,\n            id: row.id,\n            createdAt: new Date(row.created_at),\n            updatedAt: new Date(row.updated_at)\n          });\n        }\n        return results;\n      }\n      async first() {\n        const results = await this.limit(1).get();\n        return results[0] || null;\n      }\n      async count() {\n        let sql = `SELECT COUNT(*) as count FROM \"${this.tableName}\" WHERE user_id = ?`;\n        const params = [this.userId];\n        if (this.conditions.length > 0) {\n          const whereConditions = this.conditions.map((c) => {\n            const jsonPath = `$.${c.path}`;\n            switch (c.operator) {\n              case \"==\":\n                params.push(c.value);\n                return `json_extract(data, '${jsonPath}') = ?`;\n              case \"!=\":\n                params.push(c.value);\n                return `json_extract(data, '${jsonPath}') != ?`;\n              case \">\":\n                params.push(c.value);\n                return `json_extract(data, '${jsonPath}') > ?`;\n              case \"<\":\n                params.push(c.value);\n                return `json_extract(data, '${jsonPath}') < ?`;\n              case \"includes\":\n                params.push(`%${c.value}%`);\n                return `json_extract(data, '${jsonPath}') LIKE ?`;\n              default:\n                throw new Error(`Unsupported operator: ${c.operator}`);\n            }\n          });\n          sql += ` AND (${whereConditions.join(\" AND \")})`;\n        }\n        const cursor = this.storage.sql.exec(sql, ...params);\n        const row = cursor.one();\n        return row ? Number(row.count) : 0;\n      }\n    };\n  }\n});\n\n// node_modules/userdo/dist/src/database/table.js\nvar GenericTable;\nvar init_table = __esm({\n  \"node_modules/userdo/dist/src/database/table.js\"() {\n    init_query();\n    GenericTable = class {\n      static {\n        __name(this, \"GenericTable\");\n      }\n      constructor(tableName, schema, storage, userId, broadcast) {\n        this.tableName = tableName;\n        this.schema = schema;\n        this.storage = storage;\n        this.userId = userId;\n        this.broadcast = broadcast;\n      }\n      async create(data) {\n        const validated = this.schema.parse(data);\n        const id = crypto.randomUUID();\n        const now = Date.now();\n        const insertSQL = `INSERT INTO \"${this.tableName}\" (id, data, created_at, updated_at, user_id) VALUES (?, ?, ?, ?, ?)`;\n        this.storage.sql.exec(insertSQL, id, JSON.stringify(validated), now, now, this.userId);\n        const result = { ...validated, id, createdAt: new Date(now), updatedAt: new Date(now) };\n        this.broadcast(`table:${this.tableName}:create`, { type: \"create\", data: result });\n        return result;\n      }\n      async findById(id) {\n        const selectSQL = `SELECT * FROM \"${this.tableName}\" WHERE id = ? AND user_id = ? LIMIT 1`;\n        const cursor = this.storage.sql.exec(selectSQL, id, this.userId);\n        const row = cursor.one();\n        if (!row)\n          return null;\n        const data = JSON.parse(row.data);\n        return {\n          ...data,\n          id: row.id,\n          createdAt: new Date(row.created_at),\n          updatedAt: new Date(row.updated_at)\n        };\n      }\n      async update(id, updates) {\n        const existing = await this.findById(id);\n        if (!existing)\n          throw new Error(\"Record not found\");\n        const merged = { ...existing, ...updates };\n        delete merged.id;\n        delete merged.createdAt;\n        delete merged.updatedAt;\n        const validated = this.schema.parse(merged);\n        const now = Date.now();\n        const updateSQL = `UPDATE \"${this.tableName}\" SET data = ?, updated_at = ? WHERE id = ? AND user_id = ?`;\n        this.storage.sql.exec(updateSQL, JSON.stringify(validated), now, id, this.userId);\n        const result = { ...validated, id, createdAt: existing.createdAt, updatedAt: new Date(now) };\n        this.broadcast(`table:${this.tableName}:update`, { type: \"update\", data: result });\n        return result;\n      }\n      async delete(id) {\n        const deleteSQL = `DELETE FROM \"${this.tableName}\" WHERE id = ? AND user_id = ?`;\n        this.storage.sql.exec(deleteSQL, id, this.userId);\n        this.broadcast(`table:${this.tableName}:delete`, { type: \"delete\", data: { id } });\n      }\n      where(path, operator, value) {\n        return new GenericQuery(this.tableName, this.storage, this.schema, this.userId).where(path, operator, value);\n      }\n      orderBy(field, direction = \"asc\") {\n        return new GenericQuery(this.tableName, this.storage, this.schema, this.userId).orderBy(field, direction);\n      }\n      limit(count) {\n        return new GenericQuery(this.tableName, this.storage, this.schema, this.userId).limit(count);\n      }\n      async getAll() {\n        return new GenericQuery(this.tableName, this.storage, this.schema, this.userId).get();\n      }\n      async count() {\n        const countSQL = `SELECT COUNT(*) as count FROM \"${this.tableName}\" WHERE user_id = ?`;\n        const cursor = this.storage.sql.exec(countSQL, this.userId);\n        const row = cursor.one();\n        return row ? Number(row.count) : 0;\n      }\n    };\n  }\n});\n\n// node_modules/userdo/dist/src/database/index.js\nvar UserDODatabase;\nvar init_database = __esm({\n  \"node_modules/userdo/dist/src/database/index.js\"() {\n    init_table();\n    UserDODatabase = class {\n      static {\n        __name(this, \"UserDODatabase\");\n      }\n      constructor(storage, currentUserId, broadcast) {\n        this.storage = storage;\n        this.currentUserId = currentUserId;\n        this.broadcast = broadcast;\n        this.tables = /* @__PURE__ */ new Map();\n        this.schemas = /* @__PURE__ */ new Map();\n      }\n      table(name, schema, options = {}) {\n        if (!this.tables.has(name)) {\n          this.ensureTableExists(name, options);\n          const table = new GenericTable(name, schema, this.storage, this.currentUserId, this.broadcast);\n          this.tables.set(name, table);\n          this.schemas.set(name, schema);\n        }\n        return this.tables.get(name);\n      }\n      get raw() {\n        return this.storage.sql;\n      }\n      ensureTableExists(name, options) {\n        const createSQL = `CREATE TABLE IF NOT EXISTS \"${name}\" (\n      id TEXT PRIMARY KEY,\n      data TEXT NOT NULL,\n      created_at INTEGER NOT NULL,\n      updated_at INTEGER NOT NULL,\n      user_id TEXT${options.userScoped ? \" NOT NULL\" : \"\"}\n    )`;\n        try {\n          this.storage.sql.exec(createSQL);\n        } catch (err) {\n          console.log(`Table ${name} creation result:`, err);\n        }\n      }\n    };\n  }\n});\n\n// node_modules/userdo/dist/src/UserDO.js\nimport { DurableObject } from \"cloudflare:workers\";\nfunction isReservedKey(key) {\n  return key.startsWith(RESERVED_PREFIX);\n}\nasync function hashEmailForId(email) {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(email.toLowerCase());\n  const hashBuffer = await crypto.subtle.digest(\"SHA-256\", data);\n  const hashArray = new Uint8Array(hashBuffer);\n  const hashHex = Array.from(hashArray).map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hashHex;\n}\nasync function getUserDO(namespace, email) {\n  const hashedEmail = await hashEmailForId(email);\n  return namespace.get(namespace.idFromName(hashedEmail));\n}\nasync function hashPassword(password) {\n  const encoder = new TextEncoder();\n  const saltBytes = crypto.getRandomValues(new Uint8Array(PASSWORD_CONFIG.saltLength));\n  const salt = btoa(String.fromCharCode(...saltBytes));\n  const key = await crypto.subtle.importKey(\"raw\", encoder.encode(password), { name: \"PBKDF2\" }, false, [\"deriveBits\"]);\n  const derivedBits = await crypto.subtle.deriveBits({ name: \"PBKDF2\", salt: saltBytes, iterations: PASSWORD_CONFIG.iterations, hash: \"SHA-256\" }, key, 256);\n  const hash = btoa(String.fromCharCode(...new Uint8Array(derivedBits)));\n  return { hash, salt };\n}\nasync function verifyPassword(password, salt, expectedHash) {\n  const encoder = new TextEncoder();\n  const saltBytes = Uint8Array.from(atob(salt), (c) => c.charCodeAt(0));\n  const key = await crypto.subtle.importKey(\"raw\", encoder.encode(password), { name: \"PBKDF2\" }, false, [\"deriveBits\"]);\n  const derivedBits = await crypto.subtle.deriveBits({ name: \"PBKDF2\", salt: saltBytes, iterations: PASSWORD_CONFIG.iterations, hash: \"SHA-256\" }, key, 256);\n  const hash = btoa(String.fromCharCode(...new Uint8Array(derivedBits)));\n  return hash === expectedHash;\n}\nasync function migrateUserEmail({ env, oldEmail, newEmail }) {\n  oldEmail = oldEmail.toLowerCase();\n  newEmail = newEmail.toLowerCase();\n  const oldDO = await getDO(env, oldEmail);\n  const newDO = await getDO(env, newEmail);\n  try {\n    const user = await oldDO.raw();\n    user.email = newEmail;\n    await newDO.init(user);\n    await oldDO.deleteUser();\n    return { ok: true };\n  } catch (err) {\n    return { ok: false, error: err instanceof Error ? err.message : String(err) };\n  }\n}\nvar UserSchema, SignupSchema, LoginSchema, InitSchema, PASSWORD_CONFIG, RESERVED_PREFIX, AUTH_DATA_KEY, RATE_LIMIT_KEY, RATE_LIMIT_MAX, RATE_LIMIT_WINDOW, getDO, UserDO;\nvar init_UserDO = __esm({\n  \"node_modules/userdo/dist/src/UserDO.js\"() {\n    init_esm();\n    init_cloudflare_worker_jwt();\n    init_database();\n    UserSchema = external_exports.object({\n      id: external_exports.string(),\n      email: external_exports.string().email(),\n      passwordHash: external_exports.string(),\n      salt: external_exports.string(),\n      createdAt: external_exports.string(),\n      refreshTokens: external_exports.array(external_exports.string()).default([])\n    });\n    SignupSchema = external_exports.object({\n      email: external_exports.string().email(),\n      password: external_exports.string().min(8)\n    });\n    LoginSchema = SignupSchema;\n    InitSchema = UserSchema;\n    PASSWORD_CONFIG = {\n      iterations: 1e5,\n      saltLength: 16\n    };\n    RESERVED_PREFIX = \"__\";\n    AUTH_DATA_KEY = \"__user\";\n    RATE_LIMIT_KEY = \"__rl\";\n    RATE_LIMIT_MAX = 5;\n    RATE_LIMIT_WINDOW = 6e4;\n    __name(isReservedKey, \"isReservedKey\");\n    __name(hashEmailForId, \"hashEmailForId\");\n    __name(getUserDO, \"getUserDO\");\n    getDO = /* @__PURE__ */ __name(async (env, email) => {\n      const hashedEmail = await hashEmailForId(email);\n      return env.USERDO.get(env.USERDO.idFromName(hashedEmail));\n    }, \"getDO\");\n    __name(hashPassword, \"hashPassword\");\n    __name(verifyPassword, \"verifyPassword\");\n    __name(migrateUserEmail, \"migrateUserEmail\");\n    UserDO = class extends DurableObject {\n      static {\n        __name(this, \"UserDO\");\n      }\n      constructor(state, env) {\n        super(state, env);\n        this.state = state;\n        this.storage = state.storage;\n        this.env = env;\n        this.database = new UserDODatabase(this.storage, this.getCurrentUserId(), this.broadcast.bind(this));\n      }\n      async checkRateLimit() {\n        const now = Date.now();\n        const record = await this.storage.get(RATE_LIMIT_KEY);\n        if (record && record.resetAt > now) {\n          if (record.count >= RATE_LIMIT_MAX) {\n            throw new Error(\"Too many requests\");\n          }\n          record.count += 1;\n          await this.storage.put(RATE_LIMIT_KEY, record);\n        } else {\n          const resetAt = now + RATE_LIMIT_WINDOW;\n          await this.storage.put(RATE_LIMIT_KEY, { count: 1, resetAt });\n        }\n      }\n      async signup({ email, password }) {\n        email = email.toLowerCase();\n        await this.checkRateLimit();\n        const parsed = SignupSchema.safeParse({ email, password });\n        if (!parsed.success) {\n          throw new Error(\"Invalid input: \" + JSON.stringify(parsed.error.flatten()));\n        }\n        const existing = await this.storage.get(AUTH_DATA_KEY);\n        if (existing)\n          throw new Error(\"Email already registered\");\n        const id = this.state.id.toString();\n        const createdAt = (/* @__PURE__ */ new Date()).toISOString();\n        const { hash, salt } = await hashPassword(password);\n        const user = {\n          id,\n          email,\n          passwordHash: hash,\n          salt,\n          createdAt,\n          refreshTokens: []\n        };\n        await this.storage.put(AUTH_DATA_KEY, user);\n        const accessExp = Math.floor(Date.now() / 1e3) + 15 * 60;\n        const token = await index_default.sign({\n          sub: user.id,\n          email: user.email,\n          exp: accessExp\n        }, this.env.JWT_SECRET);\n        const refreshExp = Math.floor(Date.now() / 1e3) + 7 * 24 * 60 * 60;\n        const refreshToken = await index_default.sign({\n          sub: user.id,\n          type: \"refresh\",\n          exp: refreshExp\n        }, this.env.JWT_SECRET);\n        if (!user.refreshTokens)\n          user.refreshTokens = [];\n        user.refreshTokens.push(refreshToken);\n        await this.storage.put(AUTH_DATA_KEY, user);\n        return { user, token, refreshToken };\n      }\n      async login({ email, password }) {\n        email = email.toLowerCase();\n        await this.checkRateLimit();\n        const parsed = LoginSchema.safeParse({ email, password });\n        if (!parsed.success) {\n          throw new Error(\"Invalid input: \" + JSON.stringify(parsed.error.flatten()));\n        }\n        const user = await this.storage.get(AUTH_DATA_KEY);\n        if (!user || user.email !== email)\n          throw new Error(\"Invalid credentials\");\n        const ok = await verifyPassword(password, user.salt, user.passwordHash);\n        if (!ok)\n          throw new Error(\"Invalid credentials\");\n        const accessExp = Math.floor(Date.now() / 1e3) + 15 * 60;\n        const token = await index_default.sign({\n          sub: user.id,\n          email: user.email,\n          exp: accessExp\n        }, this.env.JWT_SECRET);\n        const refreshExp = Math.floor(Date.now() / 1e3) + 7 * 24 * 60 * 60;\n        const refreshToken = await index_default.sign({\n          sub: user.id,\n          type: \"refresh\",\n          exp: refreshExp\n        }, this.env.JWT_SECRET);\n        if (!user.refreshTokens)\n          user.refreshTokens = [];\n        user.refreshTokens.push(refreshToken);\n        await this.storage.put(AUTH_DATA_KEY, user);\n        return { user, token, refreshToken };\n      }\n      async raw() {\n        const user = await this.storage.get(AUTH_DATA_KEY);\n        if (!user)\n          throw new Error(\"User not found\");\n        return user;\n      }\n      async init(user) {\n        const parsed = InitSchema.safeParse(user);\n        if (!parsed.success) {\n          throw new Error(\"Invalid input: \" + JSON.stringify(parsed.error.flatten()));\n        }\n        await this.storage.put(AUTH_DATA_KEY, user);\n        return { ok: true };\n      }\n      async deleteUser() {\n        await this.storage.delete(AUTH_DATA_KEY);\n        return { ok: true };\n      }\n      // Change password method\n      async changePassword({ oldPassword, newPassword }) {\n        const user = await this.storage.get(AUTH_DATA_KEY);\n        if (!user)\n          throw new Error(\"User not found\");\n        const ok = await verifyPassword(oldPassword, user.salt, user.passwordHash);\n        if (!ok)\n          throw new Error(\"Invalid current password\");\n        const parsed = SignupSchema.shape.password.safeParse(newPassword);\n        if (!parsed.success) {\n          throw new Error(\"Invalid new password: \" + JSON.stringify(parsed.error.flatten()));\n        }\n        const { hash, salt } = await hashPassword(newPassword);\n        user.passwordHash = hash;\n        user.salt = salt;\n        await this.storage.put(AUTH_DATA_KEY, user);\n        return { ok: true };\n      }\n      // Reset password method (for use after verifying a reset token)\n      async resetPassword({ newPassword }) {\n        const user = await this.storage.get(AUTH_DATA_KEY);\n        if (!user)\n          throw new Error(\"User not found\");\n        const parsed = SignupSchema.shape.password.safeParse(newPassword);\n        if (!parsed.success) {\n          throw new Error(\"Invalid new password: \" + JSON.stringify(parsed.error.flatten()));\n        }\n        const { hash, salt } = await hashPassword(newPassword);\n        user.passwordHash = hash;\n        user.salt = salt;\n        await this.storage.put(AUTH_DATA_KEY, user);\n        return { ok: true };\n      }\n      async verifyToken({ token }) {\n        try {\n          const verify2 = await index_default.verify(token, this.env.JWT_SECRET);\n          if (!verify2)\n            throw new Error(\"Invalid token\");\n          const { payload } = verify2;\n          if (!payload)\n            throw new Error(\"Invalid token\");\n          const { sub, email } = payload;\n          if (!sub || !email)\n            throw new Error(\"Invalid token\");\n          const user = await this.storage.get(AUTH_DATA_KEY);\n          if (!user)\n            throw new Error(\"User not found\");\n          return { ok: true, user: { id: user.id, email: user.email } };\n        } catch (err) {\n          return { ok: false, error: err instanceof Error ? err.message : String(err) };\n        }\n      }\n      async set(key, value) {\n        if (isReservedKey(key))\n          throw new Error(\"Key is reserved\");\n        await this.storage.put(key, value);\n        return { ok: true };\n      }\n      async get(key) {\n        if (isReservedKey(key))\n          throw new Error(\"Key is reserved\");\n        const value = await this.storage.get(key);\n        return value;\n      }\n      async refreshToken({ refreshToken }) {\n        try {\n          const verify2 = await index_default.verify(refreshToken, this.env.JWT_SECRET);\n          if (!verify2 || !verify2.payload || verify2.payload.type !== \"refresh\") {\n            throw new Error(\"Invalid refresh token\");\n          }\n          const user = await this.storage.get(AUTH_DATA_KEY);\n          if (!user)\n            throw new Error(\"User not found\");\n          if (!user.refreshTokens.includes(refreshToken)) {\n            throw new Error(\"Refresh token not found\");\n          }\n          const accessExp = Math.floor(Date.now() / 1e3) + 15 * 60;\n          const token = await index_default.sign({\n            sub: user.id,\n            email: user.email,\n            exp: accessExp\n          }, this.env.JWT_SECRET);\n          return { token };\n        } catch (err) {\n          throw new Error(\"Invalid refresh token\");\n        }\n      }\n      async revokeRefreshToken({ refreshToken }) {\n        const user = await this.storage.get(AUTH_DATA_KEY);\n        if (!user)\n          throw new Error(\"User not found\");\n        user.refreshTokens = user.refreshTokens.filter((token) => token !== refreshToken);\n        await this.storage.put(AUTH_DATA_KEY, user);\n        return { ok: true };\n      }\n      async revokeAllRefreshTokens() {\n        const user = await this.storage.get(AUTH_DATA_KEY);\n        if (!user)\n          throw new Error(\"User not found\");\n        user.refreshTokens = [];\n        await this.storage.put(AUTH_DATA_KEY, user);\n        return { ok: true };\n      }\n      async logout() {\n        return this.revokeAllRefreshTokens();\n      }\n      table(name, schema, options) {\n        return this.database.table(name, schema, options);\n      }\n      get db() {\n        return this.database.raw;\n      }\n      getCurrentUserId() {\n        return this.state.id.toString();\n      }\n      broadcast(_event, _data) {\n      }\n    };\n  }\n});\n\n// node_modules/userdo/dist/src/client.js\nvar UserDOClient;\nvar init_client = __esm({\n  \"node_modules/userdo/dist/src/client.js\"() {\n    UserDOClient = class {\n      static {\n        __name(this, \"UserDOClient\");\n      }\n      constructor(baseUrl) {\n        this.baseUrl = baseUrl;\n        this.user = null;\n        this.eventSource = null;\n        this.listeners = /* @__PURE__ */ new Map();\n        this.authListeners = /* @__PURE__ */ new Set();\n        this.checkAuthStatus();\n      }\n      get headers() {\n        const headers = { \"Content-Type\": \"application/json\" };\n        return headers;\n      }\n      async checkAuthStatus() {\n        try {\n          const res = await fetch(`${this.baseUrl}/me`, {\n            credentials: \"include\"\n            // Ensure cookies are sent\n          });\n          if (res.ok) {\n            const data = await res.json();\n            this.user = data.user;\n          } else {\n            this.user = null;\n          }\n        } catch {\n          this.user = null;\n        }\n        this.emitAuthChange();\n      }\n      emitAuthChange() {\n        this.authListeners.forEach((l) => l(this.user));\n      }\n      onAuthStateChanged(listener) {\n        this.authListeners.add(listener);\n        listener(this.user);\n      }\n      offAuthStateChanged(listener) {\n        this.authListeners.delete(listener);\n      }\n      async signup(email, password) {\n        const res = await fetch(`${this.baseUrl}/signup`, {\n          method: \"POST\",\n          headers: this.headers,\n          credentials: \"include\",\n          body: JSON.stringify({ email, password })\n        });\n        if (!res.ok)\n          throw new Error(await res.text());\n        const data = await res.json();\n        this.user = data.user;\n        this.emitAuthChange();\n        return data;\n      }\n      async login(email, password) {\n        const res = await fetch(`${this.baseUrl}/login`, {\n          method: \"POST\",\n          headers: this.headers,\n          credentials: \"include\",\n          body: JSON.stringify({ email, password })\n        });\n        if (!res.ok)\n          throw new Error(await res.text());\n        const data = await res.json();\n        this.user = data.user;\n        this.emitAuthChange();\n        return data;\n      }\n      async logout() {\n        await fetch(`${this.baseUrl}/logout`, {\n          method: \"POST\",\n          headers: this.headers,\n          credentials: \"include\"\n        });\n        this.user = null;\n        this.emitAuthChange();\n      }\n      on(event, listener) {\n        if (!this.listeners.has(event))\n          this.listeners.set(event, /* @__PURE__ */ new Set());\n        this.listeners.get(event).add(listener);\n      }\n      off(event, listener) {\n        this.listeners.get(event)?.delete(listener);\n      }\n      connectRealtime() {\n        if (this.eventSource)\n          return;\n        this.eventSource = new EventSource(`${this.baseUrl}/events`);\n        this.eventSource.onmessage = (ev) => {\n          const data = typeof ev.data === \"string\" ? ev.data : \"\";\n          if (!data)\n            return;\n          const parsed = JSON.parse(data);\n          const listeners = this.listeners.get(ev.type) || /* @__PURE__ */ new Set();\n          listeners.forEach((l) => l(parsed));\n        };\n      }\n      collection(name) {\n        const base = `${this.baseUrl}/${name}`;\n        const client = this;\n        return {\n          async create(data) {\n            const res = await fetch(base, {\n              method: \"POST\",\n              headers: client.headers,\n              credentials: \"include\",\n              body: JSON.stringify(data)\n            });\n            if (!res.ok)\n              throw new Error(await res.text());\n            return res.json();\n          },\n          async findById(id) {\n            const res = await fetch(`${base}/${id}`, {\n              headers: client.headers,\n              credentials: \"include\"\n            });\n            if (!res.ok)\n              throw new Error(await res.text());\n            return res.json();\n          },\n          async update(id, updates) {\n            const res = await fetch(`${base}/${id}`, {\n              method: \"PUT\",\n              headers: client.headers,\n              credentials: \"include\",\n              body: JSON.stringify(updates)\n            });\n            if (!res.ok)\n              throw new Error(await res.text());\n            return res.json();\n          },\n          async delete(id) {\n            await fetch(`${base}/${id}`, {\n              method: \"DELETE\",\n              headers: client.headers,\n              credentials: \"include\"\n            });\n          },\n          query() {\n            const params = {};\n            return {\n              where(field, op, value) {\n                params[\"where\"] = JSON.stringify([field, op, value]);\n                return this;\n              },\n              orderBy(field, dir = \"asc\") {\n                params[\"order\"] = `${field}:${dir}`;\n                return this;\n              },\n              limit(count) {\n                params[\"limit\"] = count;\n                return this;\n              },\n              async get() {\n                const qs = new URLSearchParams(params).toString();\n                const res = await fetch(`${base}?${qs}`, {\n                  headers: client.headers,\n                  credentials: \"include\"\n                });\n                if (!res.ok)\n                  throw new Error(await res.text());\n                return res.json();\n              }\n            };\n          }\n        };\n      }\n    };\n  }\n});\n\n// node_modules/userdo/dist/src/index.js\nvar src_exports = {};\n__export(src_exports, {\n  GenericQuery: () => GenericQuery,\n  GenericTable: () => GenericTable,\n  UserDO: () => UserDO,\n  UserDOClient: () => UserDOClient,\n  UserDODatabase: () => UserDODatabase,\n  getUserDO: () => getUserDO,\n  hashEmailForId: () => hashEmailForId,\n  migrateUserEmail: () => migrateUserEmail\n});\nvar init_src = __esm({\n  \"node_modules/userdo/dist/src/index.js\"() {\n    init_UserDO();\n    init_database();\n    init_table();\n    init_query();\n    init_client();\n  }\n});\n\n// src/worker.ts\ninit_esm();\nvar PostSchema = external_exports.object({\n  title: external_exports.string(),\n  content: external_exports.string(),\n  createdAt: external_exports.string()\n});\nvar MyAppDO = class {\n  static {\n    __name(this, \"MyAppDO\");\n  }\n  userDO;\n  posts;\n  ctx;\n  env;\n  constructor(ctx, env) {\n    this.ctx = ctx;\n    this.env = env;\n  }\n  async ensureUserDO() {\n    if (!this.userDO) {\n      const { UserDO: UserDO2 } = await Promise.resolve().then(() => (init_src(), src_exports));\n      this.userDO = new UserDO2(this.ctx, this.env);\n      this.posts = this.userDO.table(\"posts\", PostSchema, { userScoped: true });\n    }\n  }\n  async createPost(title, content) {\n    await this.ensureUserDO();\n    return await this.posts.create({\n      title,\n      content,\n      createdAt: (/* @__PURE__ */ new Date()).toISOString()\n    });\n  }\n  async getPosts() {\n    await this.ensureUserDO();\n    return await this.posts.orderBy(\"createdAt\", \"desc\").get();\n  }\n  async fetch(request) {\n    const url = new URL(request.url);\n    if (url.pathname === \"/posts\" && request.method === \"GET\") {\n      const posts = await this.getPosts();\n      return Response.json(posts);\n    }\n    if (url.pathname === \"/posts\" && request.method === \"POST\") {\n      const body = await request.json();\n      const post = await this.createPost(body.title, body.content);\n      return Response.json(post);\n    }\n    return new Response(\"MyAppDO is running!\", { status: 200 });\n  }\n};\nvar worker_default = {\n  async fetch(request, env) {\n    const { getUserDO: getUserDO2 } = await Promise.resolve().then(() => (init_src(), src_exports));\n    const userDOStub = await getUserDO2(env.MY_APP_DO, \"demo@example.com\");\n    const url = new URL(request.url);\n    if (url.pathname === \"/posts\" && request.method === \"GET\") {\n      return Response.json([\n        { title: \"Welcome to UserDO + Alchemy\", content: \"This is working!\", createdAt: (/* @__PURE__ */ new Date()).toISOString() }\n      ]);\n    }\n    if (url.pathname === \"/posts\" && request.method === \"POST\") {\n      const body = await request.json();\n      return Response.json({\n        title: body.title,\n        content: body.content,\n        createdAt: (/* @__PURE__ */ new Date()).toISOString(),\n        message: \"Post created successfully!\"\n      });\n    }\n    return new Response(\"UserDO + Alchemy Worker is running!\", { status: 200 });\n  }\n};\nexport {\n  MyAppDO,\n  worker_default as default\n};\n"
  },
  "props": {
    "entryPoint": "./src/worker.ts",
    "format": "esm",
    "target": "esnext",
    "platform": "node",
    "minify": false,
    "conditions": [
      "workerd",
      "worker",
      "browser"
    ],
    "absWorkingDir": "/srv/userdo/examples/alchemy",
    "keepNames": true,
    "loader": {
      ".sql": "text",
      ".json": "json"
    },
    "plugins": [
      {
        "name": "wasm"
      }
    ],
    "external": [
      "node:async_hooks",
      "node:assert",
      "node:buffer",
      "node:console",
      "node:crypto",
      "node:debug",
      "node:diagnostics_channel",
      "node:dns",
      "node:events",
      "node:inspector",
      "node:net",
      "node:path",
      "node:perf_hooks",
      "node:process",
      "node:querystring",
      "node:stream",
      "node:string_decoder",
      "node:timers",
      "node:tls",
      "node:url",
      "node:util",
      "node:zlib",
      "async_hooks",
      "assert",
      "buffer",
      "console",
      "crypto",
      "debug",
      "diagnostics_channel",
      "dns",
      "events",
      "inspector",
      "net",
      "path",
      "perf_hooks",
      "process",
      "querystring",
      "stream",
      "string_decoder",
      "timers",
      "tls",
      "url",
      "util",
      "zlib",
      "cloudflare:workers",
      "cloudflare:workflows",
      "cloudflare:*"
    ]
  }
}